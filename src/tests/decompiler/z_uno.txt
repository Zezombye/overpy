settings
{
	main
	{
		Description: "Overwatch Uno v5.1 | 22FJJ"
		Mode Name: "Uno"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Match Voice Chat: Enabled
		Max Spectators: 6
		Return To Lobby: Never
	}

	modes
	{
		Deathmatch
		{
			disabled maps
			{
				Castillo
				Château Guillard
				Château Guillard Halloween
				Kanezaka
				Malevento
				Necropolis
				Route 66
				Workshop Expanse
				Workshop Expanse Night
				Workshop Green Screen
			}
		}

		General
		{
			Enemy Health Bars: Disabled
			Game Mode Start: Immediately
		}
	}

	heroes
	{
		General
		{
			Ultimate Generation - Passive: 0%
		}
	}
}

variables
{
	global:
		0: Players
		1: MapPosition
		2: DeckSymbols
		3: DeckColors
		4: DiscardPileSymbol
		5: DiscardPileColor
		6: DiscardPileColorEffectIDs
		7: DiscardPileSymbolTextID
		8: IsCurrentlyPlayingAnimation
		9: CurrentPenalty
		10: PlayerToClearHand
		11: TurnTimeRemaining
		12: PlayerToDealTo
		13: DirectionOfPlay
		14: DirectionOfPlayTimer
		15: HighlightEffectPulseTimer
		16: HighlightBeamEffectAngle
		17: HighlightBeamEffectTargetAngle
		18: DiscardPileSymbolMovementTimer
		19: DiscardPileColorMovementTimer
		20: DiscardPileLastColor
		21: SwapCardEffectPlayers
		22: ShouldShowSpecialCardEffects
		23: SpecialCardSoundEffectVolume
		24: LastPlayedCardPlayer
		25: LastPlayedCardPosition
		26: TempPlayerIndex
		27: TempNumber
		28: TempString
		29: TempColorIndex
		30: TempSymbolIndex
		31: TempHero
		32: IS_HOLE_MAP
		33: COLORS
		34: WILD_CARD_SYMBOLS
		35: COLORED_CARD_SYMBOLS
		36: PENALTY_CARD_SYMBOLS
		37: SETTING_TURN_TIME_LIMIT
		38: SETTING_JUMP_INS
		39: SETTING_SWAP_CARDS
		40: SETTING_SWAP_ALL_CARD
		41: SETTING_MULTIPLY_CARD
		42: SETTING_COPYCAT_CARD
		43: SETTING_SHUFFLE_CARD
		44: SETTING_AMOUNT_OF_COLORS
		45: SETTING_AMOUNT_OF_NUMBERS
		46: SETTING_DEBUG
		47: SETTING_DEBUG_BOTS
		48: SETTING_COLOR_ORDER
		49: SETTING_ICON_CARDS
		50: LastPenalty
		53: TempMapPosition
		58: BoundaryRadius
		60: CURRENT_ADMIN
		62: DeckSymbolsCopy
		63: DeckColorsCopy
		64: StartingAngle
		65: SETTING_INSTANT_PLAY
		66: SETTING_CHEAT_ENABLED
		67: BoundaryForce
		69: SPECIAL_CARD_SYMBOLS
		70: NUMBER_CARD_SYMBOLS
		71: SETTING_AMOUNT_OF_STARTING_CARDS
		72: PlayersSelectedForDisplacement
		74: WHITE_CARD_SYMBOLS
		75: PlayersSelectedForDisplacementID

	player:
		0: SelectedCardIndex
		1: HandSymbols
		2: HandColors
		3: HandRenderQueueSymbols
		4: HandRenderQueueColors
		5: HandHUDTexts
		6: HandHUDTextSortOrders
		7: HandSortOrderCounter
		8: AmountOfRequestedCards
		9: IsCreatingHUDTexts
		10: MapPosition
		11: JumpInCooldown
		12: SelectedPlayerQueue
		13: SelectedPlayerHighlightPosition
		14: IsUsingCamera
		15: TempSortedHandSymbols
		16: TempSortedHandColors
		17: TempSymbols
		18: CheatsEnabled
		19: Angle
		20: IsSpectating
		21: IsSpectatorInQueueToEnter
		24: TempColor
		25: TempNumber
}

subroutines
{
	0: AddColoredSymbolsToDeck
	1: AddUncoloredSymbolsToDeck
	2: DrawCardsAndAdvanceTurn
	3: DealRequestedCards
	4: TransferCardToDiscardPile
	5: ChangeActivePlayer
	6: ChangeActivePlayer_Default
	7: ChangeActivePlayer_Skip
	8: ChangeActivePlayer_Reverse
	9: ChangeActivePlayer_Penalty
	10: ChangeActivePlayer_Swap
	11: ChangeActivePlayer_SwapAll
	12: ChangeActivePlayer_Shuffle
	13: UpdateWildCardColor
	14: ClearHandHUDTexts
	15: PlaySwapCardAnimation
	16: ToggleFloatingCamera
	17: DestroyDiscardPileCardEffects
	18: SortHandCards
	19: PlaySpecialCardAnimation
	20: UpdateHighlightBeamPosition
	21: PlayDrawCardsEffects
	22: DiscardCardCheat
	28: TransferToDeckCheat
	29: AddRandomNumberCardCheat
	30: CompletePlayerPositionSwap
	31: SetPlayerSelectionQueueForAll
	32: AddAnotherSetOfCardsToDeck
	33: InitPlayerStartingVariables
	34: UpdateMapPositionForAll
	35: AddNewPlayerToPlayers
	36: InitMapPositionForAll
	37: UpdateColorCheat
}

rule("[Game settings]")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"The amount of time in seconds a player has to complete their turn. To disable the time limit, set this variable to 0."
		Global.SETTING_TURN_TIME_LIMIT = Workshop Setting Integer(Custom String("General settings"), Custom String("Turn time limit"), 30,
			0, 120, 0);
		"When set to True, players can play a card with exactly the same symbol and color as the top card of the discard pile even when it is not their turn to play"
		Global.SETTING_JUMP_INS = Workshop Setting Toggle(Custom String("General settings"), Custom String("Allow jump-ins"), True, 0);
		"A single ×2 card is added to the deck when set to True. Multiplies the amount of cards the next player has to draw by 2, acts as a +2 if there is no draw card on the discard pile."
		Global.SETTING_MULTIPLY_CARD = Workshop Setting Toggle(Custom String("Special cards"), Custom String("Enable ×2 card"), True, 0);
		"A single swap card for every color is added to the deck when set to True. Swap cards allow players to swap their hand with another player"
		Global.SETTING_SWAP_CARDS = Workshop Setting Toggle(Custom String("Special cards"), Custom String("Enable SWAP cards"), True, 0);
		"2 copycat cards are added to the deck when set to True. Copies the last played card when played"
		Global.SETTING_COPYCAT_CARD = Workshop Setting Toggle(Custom String("Special cards"), Custom String("Enable COPYCAT card"), True,
			0);
		"A single Swap All card is added to the deck when set to true. When played, all hands are moved in the direction of play"
		Global.SETTING_SWAP_ALL_CARD = Workshop Setting Toggle(Custom String("Special cards"), Custom String("Enable SWAP ALL card"),
			False, 0);
		"A single Shuffle card is added to the deck when set to true. When played, all hands are shuffled. Each player keeps the same amount of card"
		Global.SETTING_SHUFFLE_CARD = Workshop Setting Toggle(Custom String("Special cards"), Custom String("Enable SHUFFLE card"), False,
			0);
		"The amount of card colors. Can support up to 10 colors (not recommended). Greater card variety increases the average amount of cards a player has. This increases the chance of reaching the text limit, meaning no new cards are dealt until some are discarded"
		Global.SETTING_AMOUNT_OF_COLORS = Workshop Setting Integer(Custom String("Miscellaneous settings"), Custom String(
			"Amount of colors (A large amount of colors can break the game)"), 4, 1, 10, 0);
		"The amount of card numbers (including 0). No technical limit, although the total size of the deck cannot exceed 1000 cards (If you try you'll probably just crash anyways). Larger amounts may make it more difficult to finish a game (see 'amount of colors')."
		Global.SETTING_AMOUNT_OF_NUMBERS = Workshop Setting Integer(Custom String("Miscellaneous settings"), Custom String(
			"Amount of card numbers (a large amount of cards can break the game)"), 10, 1, 20, 0);
		"The colors used in the deck. Only the first <SETTING_AMOUNT_OF_COLORS> colors are used for cards. To change the default colors of cards, move the desired colors to the top of the list using the arrows. (White is reserved for uncolored cards)"
		Global.SETTING_COLOR_ORDER = Array(String("Red"), String("Yellow"), String("Green"), String("Blue"), String("Purple"),
			Custom String("Orange"), Custom String("Aqua"), Custom String("Lime Green"), Custom String("Turquoise"), Custom String(
			"Sky Blue"));
		"Use icons instead of numbers (10 icons are used regardless of the 'amount of numbers' setting)"
		Global.SETTING_ICON_CARDS = Workshop Setting Toggle(Custom String("Miscellaneous settings"), Custom String(
			"Use icons instead of numbers"), False, 0);
		"The amount of cards players start with. This number should be at most (121 - 2 * <amount of players>) / <amount of players>, otherwise some cards may be invisible. (Note: The deck should contain enough cards to deal all players their hands)"
		Global.SETTING_AMOUNT_OF_STARTING_CARDS = Workshop Setting Integer(Custom String("Miscellaneous settings"), Custom String(
			"Amount of starting cards (a large amount of cards can cause the game to break)"), 7, 1, 20, 0);
		"When set to true, players joining after the game has started are dealt a hand and given permission to join the game. When set to false, only players at the start of the round can play, players joining late are forced to spectate until the next round."
		Global.SETTING_INSTANT_PLAY = Workshop Setting Toggle(Custom String("General settings"), Custom String("Allow mid-game joining"),
			True, 0);
		"Enables various debugging features when set to true"
		Global.SETTING_DEBUG = False;
		"Number of dummy bots to spawn, for debugging purposes"
		Global.SETTING_DEBUG_BOTS = 0;
	}
}

disabled rule("- SETUP -")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Custom String("You guys wanna play UNO real quick and I can record it and make that my upload tonight?") == True;
		Custom String("I don't have UNO so go **** off") == True;
		Custom String("Everyone has UNO dip****, it came free with your ****ing Xbox") == True;
		Custom String("I didn't get it, I have the oldest Xbox known to man") == True;
		Custom String("No you don't, I bought mine on day one you ****ing ****") == True;
		Custom String("Well, mine didn't have it") == True;
		Custom String("YOU HAVE UNOOOO YOU ****ING ****") == True;
		Custom String("I don't have it you ****ing ******") == True;
		Custom String("YOU HAVE UNOOOOOOO") == True;
		Custom String("I DON'T ****ING HAVE UNO MOTHER******") == True;
		Custom String("GO TO IT IN THE ARCADE AND YOU'LL BE ABLE TO DOWNLOAD IT FOR FREE, YOU DUMB MOTHER******", Custom String(
			"IT'S A ****ING CARD GAME, THEY DON'T EVEN CHARGE PEOPLE FOR IT")) == True;
		Custom String("I DON'T HAVE TWO, I DON'T HAVE THREE, I DON'T HAVE ****ING FOUR, I DON'T HAVE SEVEN, EIGHT, NINE, TEN, OR ELEVEN")
			== True;
		Custom String("YOU DON'T KNOW A ******* THING, IT'S ****ING UNO, IT'S FREE") == True;
		Custom String("I DON'T HAVE UNOOO") == True;
		Custom String("Is this going on youtube?") == True;
	}
}

rule("[Setup] init constants & starting variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Check if icons are used as symbols"
		If(Global.SETTING_ICON_CARDS);
			"Set the number of cards to 10"
			Global.SETTING_AMOUNT_OF_NUMBERS = 10;
		End;
		"Give the first turn at least one minute to play"
		Global.TurnTimeRemaining = Global.SETTING_TURN_TIME_LIMIT ? Max(60, Global.SETTING_TURN_TIME_LIMIT) : 0;
		"Start chasing the turn time remaining variable to 0 when the match starts"
		Chase Global Variable At Rate(TurnTimeRemaining, 0, Is Game In Progress, Destination and Rate);
		"Setup constants"
		Global.COLORS = Filtered Array(Array(String("Red"), Custom String("Orange"), String("Yellow"), Custom String("Lime Green"), String(
			"Green"), Custom String("Turquoise"), Custom String("Aqua"), Custom String("Sky Blue"), String("Blue"), String("Purple")),
			Array Contains(Array Slice(Global.SETTING_COLOR_ORDER, 0, Global.SETTING_AMOUNT_OF_COLORS), Current Array Element));
		Global.WILD_CARD_SYMBOLS = Array(Custom String("+4"), Custom String("Wild"));
		Global.PENALTY_CARD_SYMBOLS = Array(Custom String("+2"), Custom String("+4"));
		Global.WHITE_CARD_SYMBOLS = Array(Custom String("+4"), Custom String("×2"), Custom String("Copycat"), Custom String("Shuffle"),
			Custom String("Swap-All"), Custom String("Wild"));
		Global.NUMBER_CARD_SYMBOLS = Empty Array;
		Global.COLORED_CARD_SYMBOLS = Empty Array;
		"Check if icon cards are enabled"
		If(!Global.SETTING_ICON_CARDS);
			"Add every possible number"
			For Global Variable(TempSymbolIndex, 0, Global.SETTING_AMOUNT_OF_NUMBERS, 1);
				Modify Global Variable(NUMBER_CARD_SYMBOLS, Append To Array, Custom String("{0}", Global.TempSymbolIndex));
				Modify Global Variable(COLORED_CARD_SYMBOLS, Append To Array, Custom String("{0}", Global.TempSymbolIndex));
			End;
			Global.SPECIAL_CARD_SYMBOLS = Array(Custom String("+2"), Custom String("+4"), Custom String("×2"), Custom String("Copycat"),
				Custom String("Reverse"), Custom String("Shuffle"), Custom String("Skip"), Custom String("Swap"), Custom String("Swap-All"),
				Custom String("Wild"));
		Else;
			"Add every possible icon"
			Modify Global Variable(COLORED_CARD_SYMBOLS, Append To Array, Array(0, Icon String(Poison), Icon String(Moon), Icon String(Fire),
				Icon String(Dizzy), Icon String(Bolt), Icon String(Heart), Icon String(Diamond), Icon String(Spade), Icon String(Club)));
		End;
		"Setup helper variables for reverse card effects"
		Global.DirectionOfPlay = -1;
		Chase Global Variable At Rate(DirectionOfPlayTimer, 0, 1.500, Destination and Rate);
		"Set a variable for copycat messages"
		Global.LastPlayedCardPlayer = Custom String("the discard pile");
		Global.BoundaryRadius = 0.950;
		Global.BoundaryForce = 0.850;
	}
}

rule("[Setup] init gamemode settings")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Disable built-in game mode settings"
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Music;
		Disable Built-In Game Mode Scoring;
		Disable Built-In Game Mode Announcer;
	}
}

rule("[Setup] init map location")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Black Forest"
		If(Array Contains(Array(Map(Black Forest), Map(Black Forest Winter)), Current Map));
			Global.MapPosition = Random Value In Array(Array(Vector(-20.900, 12.500, 7.520), Vector(15.377, 11.800, -19.310)));
		"Blizzard World"
		Else If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Global.MapPosition = Random Value In Array(Array(Vector(-54.440, -0.200, 110.260), Vector(-45.930, -0.200, 78.220), Vector(
				-122.040, 0, 110.500), Vector(-49.870, 4.780, 93.180), Vector(-9.639, -3.800, -13.730), Vector(8.759, -3.590, -28.836)));
		"Dorado"
		Else If(Current Map == Map(Dorado));
			Global.MapPosition = Random Value In Array(Array(Vector(184.130, 14.100, 40.750), Vector(131.118, 11.300, 26.112), Vector(26.527,
				4.200, -15.760), Vector(-21.188, 0, -10.738)));
		"Ecopoint: Antarctica"
		Else If(Current Map == Map(Ecopoint: Antarctica) || Current Map == Map(Ecopoint: Antarctica Winter));
			Global.MapPosition = Random Value In Array(Array(Vector(6.460, 7.100, 35.440), Vector(6.905, 7.150, -34.932), Vector(12.222, 4.400,
				0.173)));
		"Eichenwalde"
		Else If(Current Map == Map(Eichenwalde) || Current Map == Map(Eichenwalde Halloween));
			Global.MapPosition = Random Value In Array(Array(Vector(86.890, 12.700, -72.410), Vector(119.270, 8.770, -42.850), Vector(11.720,
				5.860, -72.570)));
		"Hanamura"
		Else If(Current Map == Map(Hanamura) || Current Map == Map(Hanamura Winter));
			Global.MapPosition = Random Value In Array(Array(Vector(62.600, -1.600, 14.480), Vector(-11.530, -0.820, -85.400), Vector(-40.080,
				0.700, -108.303)));
		"Havana"
		Else If(Current Map == Map(Havana));
			Global.MapPosition = Random Value In Array(Array(Vector(55.651, 6.280, -83.225), Vector(88.873, 4.300, -66.162), Vector(140.027,
				6.280, -46.503), Vector(186.001, 11.400, -46.504), Vector(-11.381, 6, -79.200), Vector(-35.694, 6.100, -54.354), Vector(
				-60.034, 19.100, -17.452), Vector(-72.769, 4.100, -51.278), Vector(-118.810, 4.100, -91.384), Vector(18.913, 5.250, -29.269)));
		"Hollywood"
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Global.MapPosition = Random Value In Array(Array(Vector(-12.770, -0.100, 57.880), Vector(-15.550, 1.650, 3.100), Vector(-33.200,
				1.800, -129.010), Vector(-4.270, 2.100, -98.280)));
		"Horizon Lunar Colony"
		Else If(Current Map == Map(Horizon Lunar Colony));
			Global.MapPosition = Random Value In Array(Array(Vector(94.030, 12.700, -71.210), Vector(54.080, 9, -89.530), Vector(-24.740,
				2.900, -121.350), Vector(-3.586, 8.250, -0.908), Vector(-52.768, 4.930, -173.594)));
		"Ilios Lighthouse"
		Else If(Current Map == Map(Ilios Lighthouse));
			Global.MapPosition = Random Value In Array(Array(Vector(313.570, -24.620, -75.120), Vector(344.490, -24.620, -3.050), Vector(
				336.390, -25.400, 22.870), Vector(290.220, -25.400, -88.830), Vector(268.898, -23.670, -94.066), Vector(324.469, -23.720,
				40.321), Vector(312.399, -24.690, 63.545), Vector(244.193, -24.690, -101.824)));
		"Ilios Ruins"
		Else If(Current Map == Map(Ilios Ruins));
			Global.MapPosition = Random Value In Array(Array(Vector(-74.150, 62.750, -161.190), Vector(62.030, 60.400, -156.480), Vector(
				28.400, 57.400, -156.550)));
		"Ilios Well"
		Else If(Current Map == Map(Ilios Well));
			Global.MapPosition = Vector(-208.525, 0, -16.525);
			"The area of play is centered on the well. Setting this constant to True lowers the light shaft indicating the color of the discard pile card"
			Global.IS_HOLE_MAP = True;
		"King's Row"
		Else If(Current Map == Map(King's Row) || Current Map == Map(King's Row Winter));
			Global.MapPosition = Random Value In Array(Array(Vector(-92.400, 0.910, -9.790), Vector(-20.200, -0.110, -32.380), Vector(-149,
				-2.860, 24.260), Vector(-179.255, 0.200, 37.547)));
		"Lijiang Control Center"
		Else If(Current Map == Map(Lijiang Control Center) || Current Map == Map(Lijiang Control Center Lunar New Year));
			Global.MapPosition = Random Value In Array(Array(Vector(48.340, 265, 329.420), Vector(-76.674, 264.830, 359.171), Vector(-48.464,
				265, 329.667), Vector(85.037, 264.750, 367.254)));
		"Lijiang Garden"
		Else If(Current Map == Map(Lijiang Garden) || Current Map == Map(Lijiang Garden Lunar New Year));
			Global.MapPosition = Random Value In Array(Array(Vector(42.560, 95, 150), Vector(-7.214, 94.300, 133.743), Vector(-42.661, 95.290,
				150.278)));
		"Lijiang Night Market"
		Else If(Current Map == Map(Lijiang Night Market) || Current Map == Map(Lijiang Night Market Lunar New Year));
			Global.MapPosition = Random Value In Array(Array(Vector(1, -1.100, -31.900), Vector(1, -0.500, -61)));
		"Nepal Sanctum"
		Else If(Current Map == Map(Nepal Sanctum));
			Global.MapPosition = Random Value In Array(Array(Vector(83.250, 128.470, 0), Vector(81, 129.500, -106), Vector(51.208, 130.200, 0),
				Vector(83.091, 130.100, 69.812)));
		"Nepal Shrine"
		Else If(Current Map == Map(Nepal Shrine));
			Global.MapPosition = Random Value In Array(Array(Vector(-43.190, 14.970, 123.420), Vector(-43.090, 15.700, 109.962), Vector(
				-63.382, 10.300, 14.262), Vector(-41.581, 15.250, -69.886)));
		"Nepal Village"
		Else If(Current Map == Map(Nepal Village) || Current Map == Map(Nepal Village Winter));
			Global.MapPosition = Random Value In Array(Array(Vector(-195, -93.900, 0), Vector(-172.919, -98.850, 73.714), Vector(-192.026,
				-93.800, 14.091), Vector(-192.677, -93.800, -14.382)));
		"Oasis City Center"
		Else If(Current Map == Map(Oasis City Center));
			Global.MapPosition = Random Value In Array(Array(Vector(128, 2.050, 290), Vector(89.623, 1.250, 292.299), Vector(188.576, 2.200,
				230.769)));
		"Oasis Gardens"
		Else If(Current Map == Map(Oasis Gardens));
			Global.MapPosition = Random Value In Array(Array(Vector(81.700, 6.500, -308.380), Vector(202.330, 6.500, -188.080), Vector(90.234,
				2.600, -245.388), Vector(141.218, 7.640, -247.442), Vector(139.370, 2.600, -195.984), Vector(180.123, 8.150, -208.561), Vector(
				101.628, 8.150, -287.053)));
		"Oasis University"
		Else If(Current Map == Map(Oasis University));
			Global.MapPosition = Vector(-188, 15.100, 0);
			"The area of play is centered around the hole. The light shaft should be lowered"
			Global.IS_HOLE_MAP = True;
		"Paris"
		Else If(Current Map == Map(Paris));
			Global.MapPosition = Random Value In Array(Array(Vector(-53.570, 12.130, 12.430), Vector(-97.114, 11.150, -36.356)));
		"Petra"
		Else If(Current Map == Map(Petra));
			Global.MapPosition = Vector(4.440, -12.500, 46.930);
		"Temple of Anubis"
		Else If(Current Map == Map(Temple of Anubis));
			Global.MapPosition = Random Value In Array(Array(Vector(-45.460, 2, 43.400), Vector(-0.610, -1.500, -11.144)));
		"Volskaya Industries"
		Else If(Current Map == Map(Volskaya Industries));
			Global.MapPosition = Random Value In Array(Array(Vector(-57.790, -4.090, 71.080), Vector(-94.300, -1.900, 49.260), Vector(-13.680,
				-3.590, 90.210), Vector(-11.175, -6.800, 0.911), Vector(-121.529, 6.150, 32.678)));
		"Workshop Maps"
		Else If(Array Contains(Array(Map(Workshop Chamber), Map(Workshop Expanse), Map(Workshop Expanse Night), Map(Workshop Island), Map(
				Workshop Island Night)), Current Map));
			Global.MapPosition = Vector(0, 0, 0);
		"Unsupported maps"
		Else;
			Wait(5, Ignore Condition);
			Destroy All Effects;
			Destroy All In-World Text;
			Destroy All HUD Text;
			Create HUD Text(All Players(All Teams), Custom String(
				"{0}This map is currently not supported (there is not enough space, or this is a new map){0}",
				Total Time Elapsed % 1 < 0.500 ? Icon String(Warning) : String("")), Null, Null, Top, 0, Color(Red), Color(Red), Color(Red),
				Visible To and String, Visible Always);
		End;
	}
}

rule("[Setup] create deck")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Initialize the arrays"
		Global.DeckSymbols = Empty Array;
		Global.DeckColors = Empty Array;
		"Loop once for every color"
		For Global Variable(TempColorIndex, 0, Count Of(Global.COLORS), 1);
			"Add all cards for the current color"
			Call Subroutine(AddColoredSymbolsToDeck);
			"Set the color of all newly added symbols to the current color in the loop"
			While(Count Of(Global.DeckColors) < Count Of(Global.DeckSymbols));
				"The current color is added to the deckColors array until all newly added cards have been assigned a color"
				Modify Global Variable(DeckColors, Append To Array, Global.COLORS[Global.TempColorIndex]);
			End;
		End;
		"Add all uncolored symbols"
		Call Subroutine(AddUncoloredSymbolsToDeck);
		"Set the color of all newly added symbols to be uncolored"
		While(Count Of(Global.DeckColors) < Count Of(Global.DeckSymbols));
			Modify Global Variable(DeckColors, Append To Array, String("White"));
		End;
		"Select a random index of a card in the deck to use as the starting card"
		Global.TempNumber = Random Integer(0, Count Of(Global.DeckSymbols) - 1);
		"Set the starting card to the selected card"
		Global.DiscardPileSymbol = Global.DeckSymbols[Global.TempNumber];
		Global.DiscardPileColor = Global.DeckColors[Global.TempNumber];
		Global.DiscardPileLastColor = Global.DiscardPileColor;
		"Remove the starting card from the deck"
		Modify Global Variable(DeckSymbols, Remove From Array By Index, Global.TempNumber);
		Modify Global Variable(DeckColors, Remove From Array By Index, Global.TempNumber);
		"Save a copy of the created deck"
		Global.DeckSymbolsCopy = Global.DeckSymbols;
		Global.DeckColorsCopy = Global.DeckColors;
	}
}

rule("[Setup] init player status effects & buttons")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		"Players are invincible"
		Set Status(Event Player, Null, Invincible, 9999);
		"Disable various buttons"
		Disallow Button(Event Player, Button(Primary Fire));
		Disallow Button(Event Player, Button(Secondary Fire));
		Disallow Button(Event Player, Button(Ability 1));
		Disallow Button(Event Player, Button(Ability 2));
		Disallow Button(Event Player, Button(Ultimate));
	}
}

rule("[Setup] init non-spectating player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The array of players has not yet been initialized, players joining late can not join in. This player is not a spectator"
		Global.Players == Null;
	}

	actions
	{
		"Initialize player starting variables"
		Call Subroutine(InitPlayerStartingVariables);
		"Set current player mode to non-spectator since they were present during the start of the round"
		Event Player.IsSpectating = False;
		Event Player.IsSpectatorInQueueToEnter = False;
	}
}

rule("[Setup] init spectating player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The array of players has already been initialized, this player can no longer join"
		Global.Players != Null;
		"The event player is a new player"
		Array Contains(Global.Players, Event Player) == False;
	}

	actions
	{
		"Spectating players use the floating camera by default"
		Call Subroutine(ToggleFloatingCamera);
		"Spectating players are invisible"
		Set Invisible(Event Player, All);
		"Spectating players can not interact with other players"
		Set Status(Event Player, Null, Phased Out, 9999);
		"Set the player mode to spectator"
		Event Player.IsSpectating = True;
		Event Player.IsSpectatorInQueueToEnter = False;
	}
}

rule("[Setup][Instant Play] skip assemble heroes and start match")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"game is in assemble heroes phase"
		Is Assembling Heroes == True;
		"if instant play is enabled"
		Global.SETTING_INSTANT_PLAY == True;
	}

	actions
	{
		"skip assemble heroes and begin the match"
		Set Match Time(8);
	}
}

rule("[Setup][Instant Play] add spectating player to queue of people entering the game")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The array of players has already been initialized, this player can no longer join"
		Global.Players != Null;
		"The event player is a new player"
		Array Contains(Global.Players, Event Player) == False;
		"current player is a spectator"
		Event Player.IsSpectating == True;
		"current player is not in queue to join the game"
		Event Player.IsSpectatorInQueueToEnter == False;
		"jump is being pressed to enter"
		Is Button Held(Event Player, Button(Jump)) == True;
		"instant play is enabled"
		Global.SETTING_INSTANT_PLAY == True;
	}

	actions
	{
		"put the player in queue to join the game as soon as possible (after no animations are playing)"
		Event Player.IsSpectatorInQueueToEnter = True;
	}
}

rule("[Setup][Instant Play] init spectating player entering the game")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The array of players has already been initialized, this player can no longer join"
		Global.Players != Null;
		"The event player is a new player"
		Array Contains(Global.Players, Event Player) == False;
		"player is spectator"
		Event Player.IsSpectating == True;
		"player is in queue to join the game"
		Event Player.IsSpectatorInQueueToEnter == True;
		"no animation are currently playing"
		Global.IsCurrentlyPlayingAnimation == False;
		"instant play is enabled"
		Global.SETTING_INSTANT_PLAY == True;
	}

	actions
	{
		"Check whether the player is already using the floating camera"
		If(Event Player.IsUsingCamera);
			"stop the floating camera"
			Call Subroutine(ToggleFloatingCamera);
		End;
		"add new player to the list of players"
		Call Subroutine(AddNewPlayerToPlayers);
		"initialize their starting variables"
		Call Subroutine(InitPlayerStartingVariables);
		"update map position and selection queue for all players"
		Call Subroutine(SetPlayerSelectionQueueForAll);
		Call Subroutine(UpdateMapPositionForAll);
		"Move the highlight beam"
		Call Subroutine(UpdateHighlightBeamPosition);
		"player is no longer a spectator and thus no longer invisible and can interact with other players"
		Set Invisible(Event Player, None);
		Clear Status(Event Player, Phased Out);
		"player no longer a spectator or in queue to join"
		Event Player.IsSpectating = False;
		Event Player.IsSpectatorInQueueToEnter = False;
	}
}

rule("[Setup] init players when match starts")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The game has started"
		Is Game In Progress == True;
		"The array of players has not been initialized yet"
		Global.Players == Null;
		"At least one player is playing"
		Count Of(All Players(All Teams)) > 0;
		"All players have initialized their hands"
		Filtered Array(All Players(All Teams), Count Of(Current Array Element.HandSymbols) == Global.SETTING_AMOUNT_OF_STARTING_CARDS)
			== All Players(All Teams);
	}

	actions
	{
		"Initialize the array of players"
		Global.Players = Randomized Array(All Players(All Teams));
		"Select a random offset for the first player's position"
		Global.StartingAngle = Random Integer(0, 360);
		"initialize map position and selection queue for all players present during startup"
		Call Subroutine(InitMapPositionForAll);
		Call Subroutine(SetPlayerSelectionQueueForAll);
	}
}

rule("[Setup] init non-spectating players facing direction and position after their map position has been initialized")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The map is valid"
		Global.MapPosition != Null;
		"The position of this player has been initialized"
		Event Player.MapPosition != Null;
		"The player has spawned"
		Has Spawned(Event Player) == True;
	}

	actions
	{
		"Teleport the player back to their position"
		Teleport(Event Player, Event Player.MapPosition);
		"Reset the facing of the player towards the center"
		Set Facing(Event Player, Global.MapPosition - Event Player.MapPosition, To World);
	}
}

rule("[Setup][Debug] init debug settings")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Check if debug is disabled"
		If(!Global.SETTING_DEBUG);
			"Disable the inspector"
			Disable Inspector Recording;
		End;
		"Loop until all debug bots have spawned"
		While(Global.SETTING_DEBUG_BOTS);
			"Wait between spawing multiple bots"
			Wait(2, Ignore Condition);
			"Spawn a dummy bot"
			Create Dummy Bot(Random Value In Array(All Heroes), All Teams, -1, Global.MapPosition, Up);
			"Decrease the amount of bots that need to be spawned"
			Global.SETTING_DEBUG_BOTS -= 1;
		End;
	}
}

rule("[Setup][Effects] init match time")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Hero selection is over"
		Is Game In Progress == True;
	}

	actions
	{
		Set Match Time(1800);
	}
}

rule("[Setup][Effects] init highlight beam effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Chase the highlight beam position to move towards the active player"
		Chase Global Variable At Rate(HighlightBeamEffectAngle, Global.HighlightBeamEffectTargetAngle, 180, Destination and Rate);
		"Chase a variable at an increasing rate depending on how much time is left. Used to render the pulsating effects. Is reset everytime a move is made"
		Chase Global Variable At Rate(HighlightEffectPulseTimer, 10000, 1 + 4 * ((
			Global.SETTING_TURN_TIME_LIMIT - Global.TurnTimeRemaining) / Global.SETTING_TURN_TIME_LIMIT) ^ 4, Destination and Rate);
		"Create a white light shaft effect at the position of the active player, visible to all players when there is no penalty"
		Create Effect(Global.CurrentPenalty == 0 ? All Players(All Teams) : Empty Array, Light Shaft, Color(White), Vector(0, -3, 0)
			+ Global.MapPosition + 6 * Direction From Angles(Global.HighlightBeamEffectAngle, 0), 2, Visible To Position and Radius);
		"Create a white ring intersection effect at the position of the active player visible to all players when there is no penalty"
		Create Effect(Global.CurrentPenalty == 0 ? All Players(All Teams) : Empty Array, Ring, Color(White),
			Global.MapPosition + 6 * Direction From Angles(Global.HighlightBeamEffectAngle, 0), 2, Visible To Position and Radius);
		"Create a pulsating white ring intersection effect at the position of the active player visible to all players when there is no penalty"
		Create Effect(Global.CurrentPenalty == 0 ? All Players(All Teams) : Empty Array, Ring, Color(White),
			Global.MapPosition + 6 * Direction From Angles(Global.HighlightBeamEffectAngle, 0), 2 + 0.500 * Absolute Value(
			Cosine From Degrees(120 * Global.HighlightEffectPulseTimer)), Visible To Position and Radius);
		"Create a beacon sound effect audible to the active player if there is no penalty"
		Create Effect(!Global.CurrentPenalty && Global.HighlightBeamEffectTargetAngle == Global.HighlightBeamEffectAngle ? First Of(
			Global.Players) : Empty Array, Beacon Sound, Color(White), Position Of(First Of(Global.Players)),
			50 - Global.ShouldShowSpecialCardEffects * Global.SpecialCardSoundEffectVolume, Visible To Position and Radius);
		Create Effect(!Global.CurrentPenalty && Global.HighlightBeamEffectTargetAngle == Global.HighlightBeamEffectAngle ? First Of(
			Global.Players) : Empty Array, Beacon Sound, Color(White), Position Of(First Of(Global.Players)),
			50 - Global.ShouldShowSpecialCardEffects * Global.SpecialCardSoundEffectVolume, Visible To Position and Radius);
		"Create an orange light shaft effect at the position of the active player, visible to all players when there is a penalty"
		Create Effect(Global.CurrentPenalty > 0 ? All Players(All Teams) : Empty Array, Light Shaft, Color(Orange), Vector(0, -3, 0)
			+ Global.MapPosition + 6 * Direction From Angles(Global.HighlightBeamEffectAngle, 0), 2, Visible To Position and Radius);
		"Create an orange ring intersection effect at the position of the active player visible to all players when there is a penalty"
		Create Effect(Global.CurrentPenalty > 0 ? All Players(All Teams) : Empty Array, Ring, Color(Orange),
			Global.MapPosition + 6 * Direction From Angles(Global.HighlightBeamEffectAngle, 0), 2, Visible To Position and Radius);
		"Create a pulsating orange ring intersection effect at the position of the active player visible to all players when there is a penalty"
		Create Effect(Global.CurrentPenalty > 0 ? All Players(All Teams) : Empty Array, Ring, Color(Orange), 0.250 * Direction From Angles(
			240 * Global.HighlightEffectPulseTimer, 0) + Global.MapPosition + 6 * Direction From Angles(Global.HighlightBeamEffectAngle,
			0), 2.250, Visible To Position and Radius);
		"Create a decal sound effect audible to the active player if there is a penalty"
		Create Effect(Global.CurrentPenalty && Global.HighlightBeamEffectTargetAngle == Global.HighlightBeamEffectAngle ? First Of(
			Global.Players) : Empty Array, Decal Sound, Color(White), Position Of(First Of(Global.Players)), 100,
			Visible To Position and Radius);
		Create Effect(Global.CurrentPenalty && Global.HighlightBeamEffectTargetAngle == Global.HighlightBeamEffectAngle ? First Of(
			Global.Players) : Empty Array, Decal Sound, Color(White), Position Of(First Of(Global.Players)), 100,
			Visible To Position and Radius);
	}
}

rule("[Setup][Effects] init highlight beam starting angle")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The array of players has been initialized"
		Global.Players != Null;
	}

	actions
	{
		"Set the highlight beam angle & target angle to the position of the first player"
		Global.HighlightBeamEffectTargetAngle = Horizontal Angle From Direction(First Of(Global.Players).MapPosition - Global.MapPosition);
		Global.HighlightBeamEffectAngle = Global.HighlightBeamEffectTargetAngle;
	}
}

rule("[Setup][Effects] create special card effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Chase the sound volume of the swap cards effects to increase continously"
		Chase Global Variable At Rate(SpecialCardSoundEffectVolume, 100, 25, None);
		"Create a beam effect between two swapped players"
		Create Beam Effect(Global.SwapCardEffectPlayers ? All Players(All Teams) : Empty Array, Bad Beam, Up + Position Of(First Of(
			Global.SwapCardEffectPlayers)), Up + Last Of(Global.SwapCardEffectPlayers), Color(Purple), Visible To Position and Radius);
		"Create an aura around the swapped players"
		Create Effect(Global.SwapCardEffectPlayers ? All Players(All Teams) : Empty Array, Good Aura, Color(Purple), Up * 1 + First Of(
			Global.SwapCardEffectPlayers), 2, Visible To Position and Radius);
		Create Effect(Global.SwapCardEffectPlayers ? All Players(All Teams) : Empty Array, Good Aura, Color(Purple), Up * 1 + Last Of(
			Global.SwapCardEffectPlayers), 2, Visible To Position and Radius);
		"Create some sound effects"
		Create Effect(Global.SwapCardEffectPlayers || Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Empty Array,
			Energy Sound, Color(White), Global.MapPosition, Global.SpecialCardSoundEffectVolume, Visible To Position and Radius);
		Create Effect(Global.SwapCardEffectPlayers || Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Empty Array,
			Decal Sound, Color(White), Global.MapPosition, Global.SpecialCardSoundEffectVolume, Visible To Position and Radius);
		Create Effect(Global.SwapCardEffectPlayers || Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Empty Array,
			Decal Sound, Color(White), Global.MapPosition, Global.SpecialCardSoundEffectVolume, Visible To Position and Radius);
		Create Effect(Global.SwapCardEffectPlayers || Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Empty Array,
			Decal Sound, Color(White), Global.MapPosition, Global.SpecialCardSoundEffectVolume, Visible To Position and Radius);
		Create Effect(Global.SwapCardEffectPlayers || Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Empty Array,
			Decal Sound, Color(White), Global.MapPosition, Global.SpecialCardSoundEffectVolume, Visible To Position and Radius);
		"Create some sparkles"
		Create Effect(Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Filtered Array(Global.Players,
			Current Array Element.HandSymbols[Current Array Element.SelectedCardIndex] == Custom String("Swap-All")
			|| Current Array Element.HandSymbols[Current Array Element.SelectedCardIndex] == Custom String("Shuffle")), Sparkles, Color(
			Purple), 0.500 * Up + Global.MapPosition, 15, Visible To Position and Radius);
		Create Effect(Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Filtered Array(Global.Players,
			Current Array Element.HandSymbols[Current Array Element.SelectedCardIndex] == Custom String("Swap-All")
			|| Current Array Element.HandSymbols[Current Array Element.SelectedCardIndex] == Custom String("Shuffle")), Sparkles, Color(
			Purple), 2 * Up + Global.MapPosition, 15, Visible To Position and Radius);
		Create Effect(Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Filtered Array(Global.Players,
			Current Array Element.HandSymbols[Current Array Element.SelectedCardIndex] == Custom String("Swap-All")
			|| Current Array Element.HandSymbols[Current Array Element.SelectedCardIndex] == Custom String("Shuffle")), Sparkles, Color(
			Purple), 3.500 * Up + Global.MapPosition, 15, Visible To Position and Radius);
		Create Effect(Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Filtered Array(Global.Players,
			Current Array Element.HandSymbols[Current Array Element.SelectedCardIndex] == Custom String("Swap-All")
			|| Current Array Element.HandSymbols[Current Array Element.SelectedCardIndex] == Custom String("Shuffle")), Sparkles, Color(
			Purple), 5 * Up + Global.MapPosition, 15, Visible To Position and Radius);
	}
}

rule("[Setup][Effects] information HUD text element")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.TempString = Custom String("Uno v4.0 | Latest code: 22FJJ", String("Primary Fire"), String("Secondary Fire"));
		Global.TempString = Custom String("{2}\n\nPrimary/Secondary Fire: Cycle cards", String("Primary Fire"), String("Secondary Fire"),
			Global.TempString);
		Global.TempString = Custom String("{0}\n{1}: Play selected card", Global.TempString, String("Jump"));
		Global.TempString = Custom String("{0}\n{1}: Skip turn & draw cards", Global.TempString, String("Crouch"));
		Global.TempString = Custom String("{0}\n{1}: Sort held cards", Global.TempString, String("Interact"));
		Global.TempString = Custom String("{0}\n{1}: Toggle camera", Global.TempString, String("Ultimate Ability"));
		If(
			Global.SETTING_ICON_CARDS || Global.SETTING_COPYCAT_CARD || Global.SETTING_AMOUNT_OF_COLORS != 4 || Global.SETTING_AMOUNT_OF_NUMBERS != 10 || Global.SETTING_SHUFFLE_CARD || Global.SETTING_SWAP_ALL_CARD || Global.SETTING_SWAP_CARDS || Global.SETTING_MULTIPLY_CARD || Global.SETTING_JUMP_INS || Global.SETTING_TURN_TIME_LIMIT);
			Global.TempString = Custom String("{0}\n\nCustom rules:", Global.TempString);
			Global.TempString = Global.SETTING_TURN_TIME_LIMIT ? Custom String("{0}\nTurn time limit: {1} seconds", Global.TempString,
				Global.SETTING_TURN_TIME_LIMIT) : Global.TempString;
			Global.TempString = Global.SETTING_JUMP_INS ? Custom String("{0}\nJump-ins enabled", Global.TempString) : Global.TempString;
			Global.TempString = Global.SETTING_MULTIPLY_CARD ? Custom String("{0}\n×2 card enabled", Global.TempString) : Global.TempString;
			Global.TempString = Global.SETTING_COPYCAT_CARD ? Custom String("{0}\nCopycat cards enabled", Global.TempString)
				: Global.TempString;
			Global.TempString = Global.SETTING_SWAP_CARDS ? Custom String("{0}\nSwap cards enabled", Global.TempString) : Global.TempString;
			Global.TempString = Global.SETTING_SWAP_ALL_CARD ? Custom String("{0}\nSwap all card enabled", Global.TempString)
				: Global.TempString;
			Global.TempString = Global.SETTING_SHUFFLE_CARD ? Custom String("{0}\nShuffle card enabled", Global.TempString)
				: Global.TempString;
			Global.TempString = Global.SETTING_ICON_CARDS ? Custom String("{0}\nIcons enabled", Global.TempString) : Global.TempString;
			Global.TempString = Global.SETTING_AMOUNT_OF_COLORS != 4 ? Custom String("{0}\nAmount of colors: {1}", Global.TempString,
				Global.SETTING_AMOUNT_OF_COLORS) : Global.TempString;
			Global.TempString = Global.SETTING_AMOUNT_OF_NUMBERS != 10 ? Custom String("{0}\nAmount of numbers: {1}", Global.TempString,
				Global.SETTING_AMOUNT_OF_NUMBERS) : Global.TempString;
		End;
		Create HUD Text(All Players(All Teams), Null, Global.SETTING_DEBUG ? Custom String("{0}\n\n{1}", Global.TempString, Custom String(
			"{0}\n{1}\n{2}", String("{0}: {1}", String("Server Load"), Server Load), String("{0}: {1}", String("Server Load Average"),
			Server Load Average), String("{0}: {1}", String("Server Load Peak"), Server Load Peak))) : Global.TempString, Null, Right, 0,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
	}
}

rule("[Setup][Effects] init HUD texts & misc effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Setup the position of the last player that played a card"
		Global.LastPlayedCardPosition = Global.MapPosition;
		"Chase a variable to 0 for the movement of the discard pile symbol. When greater than 0, the discard pile symbol moves from the last player that played a card to the discard pile"
		Chase Global Variable At Rate(DiscardPileSymbolMovementTimer, 0, 1, Destination and Rate);
		"Chase a variable for the bouncy effect of the discard pile beam. When this number gets larger, the oscillation of the discard pile beam decays exponentially"
		Chase Global Variable At Rate(DiscardPileColorMovementTimer, 10000, 1, Destination and Rate);
		"Create a HUD text element to tell players it's their turn"
		Create HUD Text(First Of(Global.Players), Custom String("{0}Your turn!{1}{0}", (
			Global.TurnTimeRemaining > 10 || !Global.SETTING_TURN_TIME_LIMIT) && Total Time Elapsed % 1 < 0.500 ? Icon String(Warning)
			: String(""), Global.CurrentPenalty ? Custom String(" Take the cards or stack another") : String("")), Null, Null, Top, 2,
			Color(White), Color(White), Color(White), Visible To and String, Visible Never);
		"Create a HUD text element showing the current player"
		Create HUD Text(Remove From Array(All Players(All Teams), First Of(Global.Players)), Null, Null, Custom String("{0}'s turn {1}",
			First Of(Global.Players), Hero Icon String(Hero Of(First Of(Global.Players)))), Top, 2, Color(White), Color(White), Color(
			White), Visible To and String, Visible Always);
		"Check if there is a turn time limit"
		If(Global.SETTING_TURN_TIME_LIMIT > 0);
			"Create a HUD text displaying the turn time left"
			Create HUD Text(All Players(All Teams), Null, Global.TurnTimeRemaining > 10 ? Custom String("Turn time left: {0} seconds",
				Round To Integer(Global.TurnTimeRemaining, Up)) : String(""), Global.TurnTimeRemaining <= 10 ? Custom String(
				"{1}Turn time left: {0} seconds{1}", Round To Integer(Global.TurnTimeRemaining, Up),
				Global.TurnTimeRemaining % 1 > 0.500 ? Icon String(Warning) : String("")) : String(""), Top, 1, Color(White), Color(White),
				Color(White), Visible To and String, Visible Always);
		End;
		"Create a HUD text for spectating players"
		Create HUD Text(Remove From Array(All Players(All Teams), Global.Players), Global.SETTING_INSTANT_PLAY ? Custom String(
			"You are currently spectating. Press space (jump) to join as soon as possible!") : Custom String(
			"You are currently spectating.You will be able to join next match."), Null, Null, Top, 0.500, Color(White), Color(White),
			Color(White), Visible To and String, Visible Never);
	}
}

rule("[Setup][Effects] init non-spectating player effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"if the player is not a spectator"
		Event Player.IsSpectating == False;
	}

	actions
	{
		"Chase the current position of the selected player highlight effects to smoothly move to the currently selected player"
		Chase Player Variable At Rate(Event Player, SelectedPlayerHighlightPosition, First Of(Event Player.SelectedPlayerQueue)
			.MapPosition, 5 * (0.500 + Distance Between(Event Player.SelectedPlayerHighlightPosition, First Of(
			Event Player.SelectedPlayerQueue).MapPosition)), Destination and Rate);
		"Create effects indicating the selected player when a swap card is held"
		Create Effect(Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Swap") || (
			Global.DiscardPileSymbol == Custom String("Swap") && Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String(
			"Copycat")) ? Event Player : Null, Good Aura, Color(Purple), Event Player.SelectedPlayerHighlightPosition + Up, 2,
			Visible To Position and Radius);
		Create Effect(Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Swap") || (
			Global.DiscardPileSymbol == Custom String("Swap") && Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String(
			"Copycat")) ? Event Player : Empty Array, Ring, Color(Purple), Event Player.SelectedPlayerHighlightPosition, 2,
			Visible To Position and Radius);
		"Setup a starting position for the highlight effects indicating the selected player"
		Event Player.SelectedPlayerHighlightPosition = Global.MapPosition;
		"Create a text element which displays the amount of cards the player has above their head. Only visible to the player itself when the player is using the floating camera"
		Create In-World Text(Remove From Array(All Players(All Teams), Event Player.IsUsingCamera ? Null : Event Player), Max(1, Count Of(
			Event Player.HandSymbols)), Up * 0.500 + Eye Position(Event Player), 1.200, Do Not Clip, Visible To Position and String, Color(
			White), Visible Always);
		"Create a HUD text element indicating the selected card, with additional information about the selected card"
		Create HUD Text(Event Player, Null, Custom String("{1}Selected card: {2}{0}", Array Contains(Global.WILD_CARD_SYMBOLS,
			Event Player.HandSymbols[Event Player.SelectedCardIndex]) ? Custom String("(use {0} to select a color)", Ability Icon String(
			Hero Of(Event Player), Button(Ability 2)) == String("") ? String("Ability 2") : Ability Icon String(Hero Of(Event Player),
			Button(Ability 2))) : String(""), (Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Swap") || (
			Global.DiscardPileSymbol == Custom String("Swap") && Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String(
			"Copycat"))) && Count Of(Event Player.SelectedPlayerQueue) > 0 ? Custom String(
			"Selected player: {0} (use {1} to select the player to swap with)\n", First Of(Event Player.SelectedPlayerQueue),
			Ability Icon String(Hero Of(Event Player), Button(Ability 2)) == String("") ? String("Ability 2") : Ability Icon String(
			Hero Of(Event Player), Button(Ability 2))) : String(""),
			Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Swap") ? Custom String(
			"Swaps your hand with the selected player ") : (Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String(
			"Swap-All") ? Custom String("Moves all hands in the direction of play ") : (
			Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Shuffle") ? Custom String(
			"Shuffles the cards in all hands ") : (Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Copycat")
			? Custom String("Copies the last played card ") : (Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String(
			"×2") ? Custom String("Doubles the cards the next player has to take ") : String("")))))), Null, Left,
			Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex] - 0.500, Color(White), Color(White), Color(White),
			Visible To Sort Order and String, Visible Never);
		"Create a boundary effect showing where the player is allowed to move"
		Create Effect(Event Player, Ring, Color(White), Up * (Y Component Of(Position Of(Event Player)) + 1 * (Distance Between((
			Left + Forward) * Position Of(Event Player), (Left + Forward) * Event Player.MapPosition) - 2)) + (Left + Forward)
			* Event Player.MapPosition, 2, Visible To Position and Radius);
		"Create a beam effect to the next player for the shuffle/swap all card effect"
		Create Beam Effect(Global.ShouldShowSpecialCardEffects ? All Players(All Teams) : Empty Array, Bad Beam, Event Player,
			Global.Players[(1 + Index Of Array Value(Global.Players, Event Player)) % Count Of(Global.Players)], Color(Purple),
			Visible To Position and Radius);
		Create HUD Text(Event Player, Null, Null, First Of(Global.Players) != Event Player ? Custom String("Wait {0} turn(s)!",
			Index Of Array Value(Global.Players, Event Player)) : Custom String("Play a card!"), Top, 3, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
	}
}

rule("[Subroutine][Setup] add colored symbols to deck")
{
	event
	{
		Subroutine;
		AddColoredSymbolsToDeck;
	}

	actions
	{
		"Add a single 0 card for every color"
		Modify Global Variable(DeckSymbols, Append To Array, Custom String("0"));
		"Check if swap cards are enabled"
		If(Global.SETTING_SWAP_CARDS);
			"Add a single swap card for every color"
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Swap"));
			If(!Array Contains(Global.COLORED_CARD_SYMBOLS, Custom String("Swap")));
				Global.COLORED_CARD_SYMBOLS = Append To Array(Custom String("Swap"), Global.COLORED_CARD_SYMBOLS);
			End;
		End;
		"Add all other colored cards twice"
		For Global Variable(TempNumber, 0, 2, 1);
			If(!Global.SETTING_ICON_CARDS);
				"Add every number from 1 through <amount of numbers>"
				For Global Variable(TempSymbolIndex, 1, Global.SETTING_AMOUNT_OF_NUMBERS, 1);
					Modify Global Variable(DeckSymbols, Append To Array, Custom String("{0}", Global.TempSymbolIndex));
				End;
			Else;
				"Add 9 icons instead of numbers"
				Modify Global Variable(DeckSymbols, Append To Array, Array(Icon String(Poison), Icon String(Moon), Icon String(Fire), Icon String(
					Dizzy), Icon String(Bolt), Icon String(Heart), Icon String(Diamond), Icon String(Spade), Icon String(Club)));
			End;
			"Add special colored cards"
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Reverse"));
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Skip"));
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("+2"));
		End;
	}
}

rule("[Subroutine][Setup] add uncolored symbols to deck")
{
	event
	{
		Subroutine;
		AddUncoloredSymbolsToDeck;
	}

	actions
	{
		"Loop once for every color"
		For Global Variable(TempColorIndex, 0, Count Of(Global.COLORS), 1);
			"Add a wild and +4 card"
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Wild"));
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("+4"));
		End;
		"Check if the swap all card is enabled"
		If(Global.SETTING_SWAP_ALL_CARD);
			"Add a single swap all card"
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Swap-All"));
			Modify Global Variable(WILD_CARD_SYMBOLS, Append To Array, Custom String("Swap-All"));
		End;
		"Check if the shuffle card is enabled"
		If(Global.SETTING_SHUFFLE_CARD);
			"Add a single swap all card"
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Shuffle"));
			Modify Global Variable(WILD_CARD_SYMBOLS, Append To Array, Custom String("Shuffle"));
		End;
		"Check if the ×2 card is enabled"
		If(Global.SETTING_MULTIPLY_CARD);
			"Add a ×2 card"
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("×2"));
			Modify Global Variable(WILD_CARD_SYMBOLS, Append To Array, Custom String("×2"));
			Modify Global Variable(PENALTY_CARD_SYMBOLS, Append To Array, Custom String("×2"));
		End;
		"Check if copycat cards are enabled"
		If(Global.SETTING_MULTIPLY_CARD);
			"Add two copycat cards"
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Copycat"));
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Copycat"));
		End;
	}
}

rule("[Subroutine][Setup] Add current new player to the list of players")
{
	event
	{
		Subroutine;
		AddNewPlayerToPlayers;
	}

	actions
	{
		Modify Global Variable(Players, Append To Array, Event Player);
	}
}

rule("[Subroutine][Setup] Initialize player variables")
{
	event
	{
		Subroutine;
		InitPlayerStartingVariables;
	}

	actions
	{
		Event Player.HandSymbols = Empty Array;
		Event Player.HandColors = Empty Array;
		Event Player.HandRenderQueueSymbols = Empty Array;
		Event Player.HandRenderQueueColors = Empty Array;
		Event Player.HandHUDTexts = Empty Array;
		Event Player.HandHUDTextSortOrders = Empty Array;
		"Request the starting cards"
		Event Player.AmountOfRequestedCards = Global.SETTING_AMOUNT_OF_STARTING_CARDS;
		Call Subroutine(DealRequestedCards);
		"Sort the player's hand"
		Call Subroutine(SortHandCards);
	}
}

rule("[Subroutine][Setup] Init player map position for all players for the first time")
{
	event
	{
		Subroutine;
		InitMapPositionForAll;
	}

	actions
	{
		"Loop over every player"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			Global.Players[Global.TempPlayerIndex].Angle = 360 / Count Of(Global.Players) * (
				-1 * Global.DirectionOfPlay * Global.TempPlayerIndex % Count Of(Global.Players)) + Global.StartingAngle;
			"The players' positions are placed in a circle centered on the map position, equally spaced from one another"
			Global.Players[Global.TempPlayerIndex].MapPosition = Direction From Angles(Global.Players[Global.TempPlayerIndex].Angle, 0)
				* 6 + Global.MapPosition;
			Global.Players[Global.TempPlayerIndex].MapPosition = Ray Cast Hit Position(
				Up * 1.500 + Global.Players[Global.TempPlayerIndex].MapPosition,
				Up * -1.500 + Global.Players[Global.TempPlayerIndex].MapPosition, Empty Array, Empty Array, False);
		End;
	}
}

rule("[Subroutine] Update player map position for all players for the first time")
{
	event
	{
		Subroutine;
		UpdateMapPositionForAll;
	}

	actions
	{
		If(Count Of(Global.Players) > 1);
			"Select a random offset for the first player's position"
			Global.StartingAngle = First Of(Global.Players).Angle;
			"Loop over every player"
			For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
				Global.Players[Global.TempPlayerIndex].Angle = 360 / Count Of(Global.Players) * (
					-1 * Global.DirectionOfPlay * Global.TempPlayerIndex % Count Of(Global.Players)) + Global.StartingAngle;
				"The players' positions are placed in a circle centered on the map position, equally spaced from one another"
				Global.Players[Global.TempPlayerIndex].MapPosition = Direction From Angles(Global.Players[Global.TempPlayerIndex].Angle, 0)
					* 6 + Global.MapPosition;
				Global.Players[Global.TempPlayerIndex].MapPosition = Ray Cast Hit Position(
					Up * 1.500 + Global.Players[Global.TempPlayerIndex].MapPosition,
					Up * -1.500 + Global.Players[Global.TempPlayerIndex].MapPosition, Empty Array, Empty Array, False);
			End;
		End;
	}
}

rule("[Subroutine] Set player selection queue for all players")
{
	event
	{
		Subroutine;
		SetPlayerSelectionQueueForAll;
	}

	actions
	{
		"Loop over every player"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			"Set the selected player queue for this player to the array of all players without the current player. The first value in this array is the player with which is swapped when a swap card is played by this player"
			Global.Players[Global.TempPlayerIndex].SelectedPlayerQueue = Remove From Array(Global.Players,
				Global.Players[Global.TempPlayerIndex]);
		End;
	}
}

disabled rule("- CARD EFFECT STUFF -")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[Effects] update discard pile color (white)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to white"
		Global.DiscardPileColor == String("White");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		"Create the symbol effect"
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? Custom String("Wild (any color)")
			: Global.DiscardPileSymbol)), (1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(White),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(White), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(White), Global.MapPosition + Up * 2, 1.250, Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(White), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(White), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(White), Global.MapPosition + Up * 2, 50);
		"Create effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(White), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(White), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(White), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (red)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to red"
		Global.DiscardPileColor == String("Red");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? String("Red") : Global.DiscardPileSymbol)), (
			1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Red),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Red), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Red), Global.MapPosition + Up * 2, 1.250, Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Red), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Red), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Red), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Red), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Red), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (orange)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to orange"
		Global.DiscardPileColor == Custom String("Orange");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? Custom String("Orange")
			: Global.DiscardPileSymbol)), (1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Orange),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Orange), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Orange), Global.MapPosition + Up * 2, 1.250, Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Orange), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Orange), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Orange), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Orange), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Orange), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (yellow)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to yellow"
		Global.DiscardPileColor == String("Yellow");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? String("Yellow") : Global.DiscardPileSymbol)), (
			1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Yellow),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Yellow), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Yellow), Global.MapPosition + Up * 2, 1.250, Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Yellow), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Yellow), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Yellow), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Yellow), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Yellow), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Yellow), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (lime green)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to lime green"
		Global.DiscardPileColor == Custom String("Lime Green");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		"Create the symbol effect"
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? Custom String("Lime Green")
			: Global.DiscardPileSymbol)), (1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Lime Green),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Lime Green), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Lime Green), Global.MapPosition + Up * 2, 1.250,
			Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Lime Green), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Lime Green), Global.MapPosition + Up * 2, 50);
		"Create effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Lime Green), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Lime Green), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Lime Green), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (green)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to green"
		Global.DiscardPileColor == String("Green");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? String("Green") : Global.DiscardPileSymbol)), (
			1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Green),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Green), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Green), Global.MapPosition + Up * 2, 1.250, Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Green), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Green), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Green), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Green), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Green), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Green), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (turquoise)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to turquoise"
		Global.DiscardPileColor == Custom String("Turquoise");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? Custom String("Turquoise")
			: Global.DiscardPileSymbol)), (1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Turquoise),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Turquoise), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Turquoise), Global.MapPosition + Up * 2, 1.250,
			Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Turquoise), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Turquoise), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Turquoise), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Turquoise), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Turquoise), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Turquoise), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (aqua)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to aqua"
		Global.DiscardPileColor == Custom String("Aqua");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? Custom String("Aqua")
			: Global.DiscardPileSymbol)), (1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Aqua),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Aqua), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Aqua), Global.MapPosition + Up * 2, 1.250, Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Aqua), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Aqua), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Aqua), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Aqua), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Aqua), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Aqua), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (sky blue)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to sky blue"
		Global.DiscardPileColor == Custom String("Sky Blue");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? Custom String("Sky Blue")
			: Global.DiscardPileSymbol)), (1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Sky Blue),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Sky Blue), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Sky Blue), Global.MapPosition + Up * 2, 1.250,
			Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Sky Blue), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Sky Blue), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Sky Blue), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Sky Blue), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Sky Blue), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Sky Blue), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (blue)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to blue"
		Global.DiscardPileColor == String("Blue");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? String("Blue") : Global.DiscardPileSymbol)), (
			1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Blue),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Blue), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Blue), Global.MapPosition + Up * 2, 1.250, Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Blue), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Blue), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Blue), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Blue), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Blue), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Blue), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] update discard pile color (purple)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The color of the discard pile card has changed to purplr"
		Global.DiscardPileColor == String("Purple");
	}

	actions
	{
		"Destroy the previous symbol effect"
		Destroy In-World Text(Global.DiscardPileSymbolTextID);
		Create In-World Text(All Players(All Teams), Global.DiscardPileSymbolMovementTimer && Last Of(Global.DeckSymbols) == Custom String(
			"Copycat") ? Custom String("Copycat") : (Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol)
			&& !Global.DiscardPileSymbolMovementTimer ? String("{0} {1}", Global.DiscardPileSymbol, Custom String("(+{0})",
			Global.CurrentPenalty)) : (Global.DiscardPileSymbol == Custom String("Wild") ? String("Purple") : Global.DiscardPileSymbol)), (
			1 - Global.DiscardPileSymbolMovementTimer)
			* Global.MapPosition + Global.DiscardPileSymbolMovementTimer * Global.LastPlayedCardPosition + Up * (
			1.500 + 0.200 * Cosine From Degrees(Total Time Elapsed * 36) + 3 * (1 - Absolute Value(
			2 * Global.DiscardPileSymbolMovementTimer - 1) ^ 2)), 10, Do Not Clip, Visible To Position and String, Color(Purple),
			Visible Always);
		Global.DiscardPileSymbolTextID = Last Text ID;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		"Destroy all existing discard pile color effects"
		Call Subroutine(DestroyDiscardPileCardEffects);
		"Create the 'intersection' effect where the light shaft reaches the ground"
		Create Effect(All Players(All Teams), Ring, Color(Purple), Global.MapPosition, 3.750 + 0.750 * Sine From Degrees(
			Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (-1 * Global.DiscardPileColorMovementTimer),
			Visible To Position and Radius);
		Global.DiscardPileColorEffectIDs = Last Created Entity;
		"Create the bad aura effect at the position of the discard pile symbol"
		Create Effect(All Players(All Teams), Bad Aura, Color(Purple), Global.MapPosition + Up * 2, 1.250, Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Create the light shaft effect"
		Create Effect(All Players(All Teams), Light Shaft, Color(Purple), Global.MapPosition + Down * (Global.IS_HOLE_MAP ? 15 : 2),
			3.750 + 0.750 * Sine From Degrees(Global.DiscardPileColorMovementTimer * 360) * 2.720 ^ (
			-1 * Global.DiscardPileColorMovementTimer), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		"Play a transition effect"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Purple), Global.MapPosition + Up * 2, 5);
		Play Effect(All Players(All Teams), Explosion Sound, Color(Purple), Global.MapPosition + Up * 2, 50);
		"Create the symbol effectCreate effects for reverse cards"
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay + 120, 0), Color(Purple), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay + 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay - 120, 0), Color(Purple), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
		Create Beam Effect(Global.DirectionOfPlayTimer ? All Players(All Teams) : Empty Array, Good Beam, Global.MapPosition + Up * 2 * (
			1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + 4)
			* Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer) ^ 2 * 50 * Global.DirectionOfPlay - 120, 0),
			Global.MapPosition + Up * 2 * (1 - Absolute Value(Global.DirectionOfPlayTimer / 5)) ^ 2 + (-4 * (1 - Absolute Value(
			Global.DirectionOfPlayTimer / 5)) ^ 2 + 4) * Direction From Angles(Absolute Value(Global.DirectionOfPlayTimer)
			^ 2 * 50 * Global.DirectionOfPlay, 0), Color(Purple), Visible To Position and Radius);
		Modify Global Variable(DiscardPileColorEffectIDs, Append To Array, Last Created Entity);
	}
}

rule("[Effects] render hand cards in queue")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"New cards have been queued to be rendered for this player"
		Count Of(Event Player.HandRenderQueueSymbols) > 0;
		"Prevent creating HUD texts when the player is not fully loaded in"
		Has Spawned(Event Player) == True;
	}

	actions
	{
		"Cards are not drawn all at the same time to reduce server load. A player's hand should not be modified when they are creating HUD texts, as this can cause their hand to be in an invalid state"
		Event Player.IsCreatingHUDTexts = True;
		"Loop until the queue is empty"
		While(Count Of(Event Player.HandRenderQueueSymbols) > 0);
			"The next card in queue is uncolored"
			If(First Of(Event Player.HandRenderQueueColors) == String("White"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(White), Color(White), Color(White), Visible To, Visible Never);
			"The next card in queue is red"
			Else If(First Of(Event Player.HandRenderQueueColors) == String("Red"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Red), Color(Red), Color(Red), Visible To, Visible Never);
			"The next card in queue is orange"
			Else If(First Of(Event Player.HandRenderQueueColors) == Custom String("Orange"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Orange), Color(Orange), Color(Orange), Visible To, Visible Never);
			"The next card in queue is yellow"
			Else If(First Of(Event Player.HandRenderQueueColors) == String("Yellow"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Yellow), Color(Yellow), Color(Yellow), Visible To, Visible Never);
			"The next card in queue is lime green"
			Else If(First Of(Event Player.HandRenderQueueColors) == Custom String("Lime Green"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Lime Green), Color(Lime Green), Color(Lime Green), Visible To, Visible Never);
			"The next card in queue is green"
			Else If(First Of(Event Player.HandRenderQueueColors) == String("Green"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Green), Color(Green), Color(Green), Visible To, Visible Never);
			"The next card in queue is turquoise"
			Else If(First Of(Event Player.HandRenderQueueColors) == Custom String("Turquoise"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Turquoise), Color(Turquoise), Color(Turquoise), Visible To, Visible Never);
			"The next card in queue is aqua"
			Else If(First Of(Event Player.HandRenderQueueColors) == Custom String("Aqua"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Aqua), Color(Aqua), Color(Aqua), Visible To, Visible Never);
			"The next card in queue is sky blue"
			Else If(First Of(Event Player.HandRenderQueueColors) == Custom String("Sky Blue"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Sky Blue), Color(Sky Blue), Color(Sky Blue), Visible To, Visible Never);
			"The next card in queue is blue"
			Else If(First Of(Event Player.HandRenderQueueColors) == String("Blue"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Blue), Color(Blue), Color(Blue), Visible To, Visible Never);
			"The next card in queue is purple"
			Else If(First Of(Event Player.HandRenderQueueColors) == String("Purple"));
				Create HUD Text(Event Player, First Of(Event Player.HandRenderQueueSymbols), Null, Null, Left, Event Player.HandSortOrderCounter,
					Color(Purple), Color(Purple), Color(Purple), Visible To, Visible Never);
			End;
			"Keep track of the HUD text ID to delete it when the card is played. The ID's in this array are kept in the same order as the cards of the player"
			Modify Player Variable(Event Player, HandHUDTexts, Append To Array, Last Text ID);
			"Keep track of the sort order of the created HUD text element"
			Modify Player Variable(Event Player, HandHUDTextSortOrders, Append To Array, Event Player.HandSortOrderCounter);
			"Wait to give the hud text the time to get created, and to reduce server load"
			Wait(0.048, Ignore Condition);
			"Remove the card from the queue"
			Modify Player Variable(Event Player, HandRenderQueueSymbols, Remove From Array By Index, 0);
			Modify Player Variable(Event Player, HandRenderQueueColors, Remove From Array By Index, 0);
			"Increase the sort order counter for hand cards to guarantee the next rendered hand card is displayed below this one"
			Event Player.HandSortOrderCounter += 1;
		End;
		"This player has created all HUD texts"
		Event Player.IsCreatingHUDTexts = False;
		"Restart this action if the conditions become true again next tick"
		Wait(0.016, Restart When True);
		Loop If Condition Is True;
	}
}

rule("[Subroutine][Effects] destroy discard pile effects")
{
	event
	{
		Subroutine;
		DestroyDiscardPileCardEffects;
	}

	actions
	{
		"Destroy all existing discard pile color effects"
		For Global Variable(TempNumber, 0, Count Of(Global.DiscardPileColorEffectIDs), 1);
			Destroy Effect(Global.DiscardPileColorEffectIDs[Global.TempNumber]);
		End;
	}
}

rule("[Subroutine][Effects] update selected card color")
{
	event
	{
		Subroutine;
		UpdateWildCardColor;
	}

	actions
	{
		"Destroy the currently selected HUD text"
		Destroy HUD Text(Event Player.HandHUDTexts[Event Player.SelectedCardIndex]);
		"The the selected card is red"
		If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Red"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Red), Color(Red), Color(Red), Visible To,
				Visible Never);
		"The next card in queue is orange"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Orange"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Orange), Color(Orange), Color(Orange), Visible To,
				Visible Never);
		"The next card in queue is yellow"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Yellow"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Yellow), Color(Yellow), Color(Yellow), Visible To,
				Visible Never);
		"The next card in queue is lime green"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Lime Green"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Lime Green), Color(Lime Green), Color(Lime Green),
				Visible To, Visible Never);
		"The next card in queue is green"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Green"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Green), Color(Green), Color(Green), Visible To,
				Visible Never);
		"The next card in queue is turquoise"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Turquoise"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Turquoise), Color(Turquoise), Color(Turquoise),
				Visible To, Visible Never);
		"The next card in queue is aqua"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Aqua"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Aqua), Color(Aqua), Color(Aqua), Visible To,
				Visible Never);
		"The next card in queue is sky blue"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Sky Blue"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Sky Blue), Color(Sky Blue), Color(Sky Blue),
				Visible To, Visible Never);
		"The next card in queue is blue"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Blue"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Blue), Color(Blue), Color(Blue), Visible To,
				Visible Never);
		"The next card in queue is purple"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Purple"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Purple), Color(Purple), Color(Purple), Visible To,
				Visible Never);
		End;
		"Keep track of the HUD text ID to delete it when the card is played"
		Event Player.HandHUDTexts[Event Player.SelectedCardIndex] = Last Text ID;
	}
}

rule("[Subroutine][Effects] clear hand HUD texts")
{
	event
	{
		Subroutine;
		ClearHandHUDTexts;
	}

	actions
	{
		"Loop over the HUD text ID's of the player"
		For Global Variable(TempNumber, 0, Count Of(Global.PlayerToClearHand.HandHUDTexts), 1);
			"Destroy all existing cards"
			Destroy HUD Text(Global.PlayerToClearHand.HandHUDTexts[Global.TempNumber]);
		End;
		"Reset the hand HUD text array"
		Global.PlayerToClearHand.HandHUDTexts = Empty Array;
		"Reset the sort order array"
		Global.PlayerToClearHand.HandHUDTextSortOrders = Empty Array;
	}
}

disabled rule("- MISC -")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[Logic] remove player when left")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	conditions
	{
		Global.Players != Empty Array;
	}

	actions
	{
		If(First Of(Global.Players) == Event Player);
			Global.TurnTimeRemaining = Global.SETTING_TURN_TIME_LIMIT;
		End;
		"Remove the leaving player from the playing players. The cards held by this player can not be added back to the deck, because the player variables of this player no longer exist"
		Global.Players = Remove From Array(Global.Players, Event Player);
		"Loop over every player that is still playing"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			"Remove the leaving player from their selected player queue"
			Modify Player Variable(Global.Players[Global.TempPlayerIndex], SelectedPlayerQueue, Remove From Array By Value, Event Player);
		End;
		Call Subroutine(UpdateMapPositionForAll);
		"Move the highlight beam when needed"
		Call Subroutine(UpdateHighlightBeamPosition);
	}
}

rule("[Effects] teleport player to position")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The map is valid"
		Global.MapPosition != Null;
		"The position of this player has been initialized"
		Event Player.MapPosition != Null;
		"The player has spawned"
		Has Spawned(Event Player) == True;
		"if the player is way out of position (12 m away)"
		(Distance Between(Vector(X Component Of(Position Of(Event Player)), Y Component Of(Event Player.MapPosition), Z Component Of(
			Position Of(Event Player))), Event Player.MapPosition) > 12 || Y Component Of(Position Of(Event Player)) - Y Component Of(
			Event Player.MapPosition) < -5) == True;
	}

	actions
	{
		"Teleport the player back to their position"
		Teleport(Event Player, Event Player.MapPosition);
		"Reset the facing of the player towards the center"
		Set Facing(Event Player, Global.MapPosition - Event Player.MapPosition, To World);
	}
}

rule("[Effects] keep player in position")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The map is valid"
		Global.MapPosition != Null;
		"The position of this player has been initialized"
		Event Player.MapPosition != Null;
		"The player has spawned"
		Has Spawned(Event Player) == True;
		"if the player is slightly out of position"
		Distance Between(Vector(X Component Of(Position Of(Event Player)), Y Component Of(Event Player.MapPosition), Z Component Of(
			Position Of(Event Player))), Event Player.MapPosition) > Global.BoundaryRadius;
		Distance Between(Vector(X Component Of(Position Of(Event Player)), Y Component Of(Event Player.MapPosition), Z Component Of(
			Position Of(Event Player))), Event Player.MapPosition) <= 12;
	}

	actions
	{
		"cancel their movement and apply a force to push them back into their boundary"
		Apply Impulse(Event Player, Direction Towards(Eye Position(Event Player), Event Player.MapPosition) * (Forward + Left),
			Global.BoundaryForce * ((Distance Between(Event Player, Event Player.MapPosition) - (Global.BoundaryRadius - Square Root(
			Global.BoundaryRadius))) / Square Root(Global.BoundaryRadius)) ^ 1, To World, Cancel Contrary Motion);
		Wait(0, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[Effects] update player score")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The current score of the player is not equal to the number of cards they have"
		Score Of(Event Player) != -1 * Count Of(Event Player.HandSymbols);
		"Check if the game has started"
		Is Game In Progress == True;
	}

	actions
	{
		"Set the score of the player to the number of cards they have"
		Set Player Score(Event Player, -1 * Count Of(Event Player.HandSymbols));
		"Check for uno"
		If(Count Of(Event Player.HandSymbols) == 1);
			"Show a message"
			Small Message(All Players(All Teams), Is True For All(Global.Players, Count Of(Current Array Element.HandSymbols) == 1)
				? Custom String("Everyone has UNO!") : Custom String("{0} has UNO!", Event Player));
			"Set the player to be burning"
			Set Status(Event Player, Null, Burning, 9999);
		Else;
			"This player no longer has uno"
			Clear Status(Event Player, Burning);
		End;
	}
}

rule("[Effects] notify active player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		First Of(Global.Players) == Event Player;
		"Wait until the beam has reached the player"
		Global.HighlightBeamEffectAngle == Global.HighlightBeamEffectTargetAngle;
	}

	actions
	{
		"Notify the new active player"
		Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 50);
	}
}

rule("[Effects] toggle floating camera")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player has pressed their ultimate button"
		Is Button Held(Event Player, Button(Ultimate)) == True;
		"The event player is not holding ability one"
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		"Toggle the floating camera for this player"
		Call Subroutine(ToggleFloatingCamera);
	}
}

rule("[Subroutine][Effects] toggle floating camera")
{
	event
	{
		Subroutine;
		ToggleFloatingCamera;
	}

	actions
	{
		"Check whether the player is already using the floating camera"
		If(Event Player.IsUsingCamera);
			"Stop using the camera"
			Stop Camera(Event Player);
		"The player is not using the camera"
		Else;
			"I don't even know"
			Start Camera(Event Player, Ray Cast Hit Position(Global.MapPosition + Up * 2, Global.MapPosition + Vector(9 * Cosine From Degrees(
				Total Time Elapsed * 4), 3.500 + 1.500 * Cosine From Degrees(3 * Total Time Elapsed), 9 * Sine From Degrees(
				Total Time Elapsed * 4)), Empty Array, Empty Array, False) - Vector(9 * Cosine From Degrees(Total Time Elapsed * 4),
				3.500 + 1.500 * Cosine From Degrees(3 * Total Time Elapsed), 9 * Sine From Degrees(Total Time Elapsed * 4)) * 0.100,
				Global.MapPosition + Up * 2, 4);
		End;
		"Update the isUsingCamera variable"
		Event Player.IsUsingCamera = !Event Player.IsUsingCamera;
	}
}

rule("[Debug] Spawn Bot")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The host is holding interact (without shift)"
		Is Button Held(Host Player, Button(Interact)) == True;
		Is Button Held(Host Player, Button(Ability 1)) == True;
		"debug mode is enabled"
		Global.SETTING_DEBUG == True;
	}

	actions
	{
		Wait(1, Abort When False);
		"Spawn a dummy bot"
		Create Dummy Bot(Random Value In Array(All Heroes), All Teams, -1, Global.MapPosition, Up);
	}
}

rule("[Debug] Destroy Bot")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"The host is holding interact and shift"
		Is Button Held(Host Player, Button(Ability 1)) == True;
		Is Button Held(Host Player, Button(Interact)) == True;
		"debug mode is enabled"
		Global.SETTING_DEBUG == True;
		"if the closest player to reticle of host player is a bot"
		Is Dummy Bot(Player Closest To Reticle(Host Player, All Teams)) == True;
	}

	actions
	{
		Wait(1, Abort When False);
		"destroy the closest dummy bot to reticle"
		Destroy Dummy Bot(All Teams, Slot Of(Player Closest To Reticle(Host Player, All Teams)));
	}
}

disabled rule("- CARD DEALING LOGIC -")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[Debug] force skip player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Debug is enabled"
		Global.SETTING_DEBUG == True;
		"The host is holding reload"
		Is Button Held(Host Player, Button(Reload)) == True;
		"It is currently the event player's turn. This rule is 'ongoing - each player', because the event player value is used in drawCards. Also, when the host player is holding reload and a player plays a card, the timer resets"
		Event Player == First Of(Global.Players);
	}

	actions
	{
		"The host must hold reload for one second"
		Wait(1, Abort When False);
		"A players hand cannot be modified when something important is happening"
		Abort If(Global.IsCurrentlyPlayingAnimation || Event Player.IsCreatingHUDTexts);
		"Show a message"
		Small Message(All Players(All Teams), Custom String("{0} was skipped by the host", Event Player));
		"Make the current active player draw a card and pass the turn to the next player (does not work with multi-draw enabled)"
		Call Subroutine(DrawCardsAndAdvanceTurn);
	}
}

rule("[Logic] take new card(s) manually")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"It is currently the event player's turn"
		First Of(Global.Players) == Event Player;
		"The player is crouching"
		Is Button Held(Event Player, Button(Crouch)) == True;
		"The player is not jumping. Prevents the player from drawing a card and playing a card in the same turn"
		Is Button Held(Event Player, Button(Jump)) == False;
	}

	actions
	{
		"A players hand cannot be modified when something important is happening"
		Abort If(Global.IsCurrentlyPlayingAnimation || Event Player.IsCreatingHUDTexts);
		"Draw the requested card(s), and advance to the next player"
		Call Subroutine(DrawCardsAndAdvanceTurn);
	}
}

rule("[Logic] take new card(s) when turn timer ends")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"There is a time limit for turns"
		Global.SETTING_TURN_TIME_LIMIT > 0;
		"The player did not play in time"
		Global.TurnTimeRemaining == 0;
		"It is currently the event player's turn"
		First Of(Global.Players) == Event Player;
		"A players hand cannot be modified when something important is happening"
		Global.IsCurrentlyPlayingAnimation == False;
		"A players hand cannot be modified while they are creating HUD texts"
		Event Player.IsCreatingHUDTexts == False;
	}

	actions
	{
		"Show a message"
		Small Message(All Players(All Teams), Custom String("{0} ran out of time!", Event Player));
		"Draw the requested card(s), and advance to the next player"
		Call Subroutine(DrawCardsAndAdvanceTurn);
	}
}

rule("[Subroutine] Draw card(s) and advance turn")
{
	event
	{
		Subroutine;
		DrawCardsAndAdvanceTurn;
	}

	actions
	{
		"Set the requested amount of cards of the player to at least 1, depending on the penalty"
		Event Player.AmountOfRequestedCards = Max(Global.CurrentPenalty, 1);
		"Reset the penalty for the next player"
		Global.LastPenalty = Global.CurrentPenalty;
		"Reset the penalty for the next player"
		Global.CurrentPenalty = 0;
		"Count all HUD texts"
		Global.TempNumber = Count Of(Global.Players) * 3 + 5 + (Global.SETTING_TURN_TIME_LIMIT > 0);
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			Global.TempNumber += Count Of(Global.Players[Global.TempPlayerIndex].HandSymbols);
		End;
		"Clamp the amount of requested cards such that it does not exceed the HUD text limit, leave one extra HUD text for cycling wild card colors"
		Event Player.AmountOfRequestedCards = Max(0, Min(127 - Global.TempNumber, Event Player.AmountOfRequestedCards));
		"Deal the requested card(s)"
		Call Subroutine(DealRequestedCards);
		"Reset the remaining turn time"
		Global.TurnTimeRemaining = Global.SETTING_TURN_TIME_LIMIT;
		"Advance to the next player"
		Call Subroutine(ChangeActivePlayer_Default);
		"Play some effects"
		Call Subroutine(PlayDrawCardsEffects);
	}
}

rule("[Subroutine] Deal requested cards to player")
{
	event
	{
		Subroutine;
		DealRequestedCards;
	}

	actions
	{
		"Check if there is a specific player that should be dealt cards"
		If(!Global.PlayerToDealTo);
			"There is no specific player, deal to the event player"
			Global.PlayerToDealTo = Event Player;
		End;
		"Loop until all requested cards have been dealt or there are no more cards in the deck"
		While(Global.PlayerToDealTo.AmountOfRequestedCards > 0 && True);
			"if the deck isn't empty"
			If(Count Of(Global.DeckSymbols) > 0);
				"Select a random card in the deck"
				Global.TempNumber = Random Integer(0, Count Of(Global.DeckSymbols) - 1);
				"Add the card to the player's hand"
				Modify Player Variable(Global.PlayerToDealTo, HandSymbols, Append To Array, Global.DeckSymbols[Global.TempNumber]);
				Modify Player Variable(Global.PlayerToDealTo, HandColors, Append To Array, Global.DeckColors[Global.TempNumber]);
				"Render the card"
				Modify Player Variable(Global.PlayerToDealTo, HandRenderQueueSymbols, Append To Array, Global.DeckSymbols[Global.TempNumber]);
				Modify Player Variable(Global.PlayerToDealTo, HandRenderQueueColors, Append To Array, Global.DeckColors[Global.TempNumber]);
				"Remove the card from the deck"
				Modify Global Variable(DeckSymbols, Remove From Array By Index, Global.TempNumber);
				Modify Global Variable(DeckColors, Remove From Array By Index, Global.TempNumber);
				"Decrease the amount of requested cards by 1"
				Global.PlayerToDealTo.AmountOfRequestedCards -= 1;
			"if the deck is empty add another set of cards to the deck"
			Else;
				Call Subroutine(AddAnotherSetOfCardsToDeck);
			End;
		End;
		"Set requested cards to 0 if not all requested cards could be dealt"
		Global.PlayerToDealTo.AmountOfRequestedCards = 0;
		"Reset the player to deal to"
		Global.PlayerToDealTo = Null;
	}
}

rule("[Subroutine][Effects] Play draw card(s) effects")
{
	event
	{
		Subroutine;
		PlayDrawCardsEffects;
	}

	actions
	{
		"Play some effects"
		Play Effect(All Players(All Teams), Bad Pickup Effect, Color(Orange), Position Of(Event Player), 30);
		Play Effect(All Players(All Teams), Debuff Impact Sound, Color(White), Position Of(Event Player), 30);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), 0.500 * Up + Event Player.MapPosition, 5);
		"Reset the highlight pulse timer"
		Global.HighlightEffectPulseTimer = 0;
		"Move the highlight beam"
		Call Subroutine(UpdateHighlightBeamPosition);
		"Check if the player had to draw more than 1 card"
		If(Global.LastPenalty > 1);
			Wait(0.032, Restart When True);
			"Display a message"
			Small Message(All Players(All Teams), Custom String("{0} took {1} cards!", Event Player, Global.LastPenalty));
		End;
	}
}

rule("[Subroutine] Add another set of cards to deck")
{
	event
	{
		Subroutine;
		AddAnotherSetOfCardsToDeck;
	}

	actions
	{
		"add a identical copy of the deck created at start back to the deck"
		Modify Global Variable(DeckSymbols, Append To Array, Global.DeckSymbolsCopy);
		Modify Global Variable(DeckColors, Append To Array, Global.DeckColorsCopy);
	}
}

disabled rule("- CARD SELECTING LOGIC -")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[Logic] Select color")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player is currently using ability 2"
		Is Button Held(Event Player, Button(Ability 2)) == True;
		"A player cannot change the color of cards when they are creating HUD texts"
		Event Player.IsCreatingHUDTexts == False;
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		"Player has wild card selected"
		If(Array Contains(Global.WILD_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]) == True);
			"Cycle the color of the player's selected card"
			Event Player.HandColors[Event Player.SelectedCardIndex] = Global.COLORS[(Index Of Array Value(Global.COLORS,
				Event Player.HandColors[Event Player.SelectedCardIndex]) + 1) % Count Of(Global.COLORS)];
			"Re-render the currently selected card to update its color"
			Call Subroutine(UpdateWildCardColor);
		End;
	}
}

rule("[Logic] Select swap card player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The event player has a swap card selected"
		(Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Swap") || (Global.DiscardPileSymbol == Custom String(
			"Swap") && Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Copycat"))) == True;
		"The player is using ability 2"
		Is Button Held(Event Player, Button(Ability 2)) == True;
		"There is at least one player to swap with"
		Event Player.SelectedPlayerQueue != Empty Array;
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		"Cycle the selected player queue"
		Modify Player Variable(Event Player, SelectedPlayerQueue, Append To Array, First Of(Event Player.SelectedPlayerQueue));
		Modify Player Variable(Event Player, SelectedPlayerQueue, Remove From Array By Index, 0);
	}
}

rule("[Logic] Select card (next)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player is holding secondary fire"
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		"The player is not holding primary fire"
		Is Button Held(Event Player, Button(Primary Fire)) == False;
		"The player is not a spectator"
		Array Contains(Global.Players, Event Player) == True;
		"The event player is not holding ability one"
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		"Increase the index of the selected card by one, loop back to 0 when needed"
		Event Player.SelectedCardIndex = (Event Player.SelectedCardIndex + 1) % Count Of(Event Player.HandSymbols);
		Wait(0.250, Abort When False);
		"Fast scrolling"
		While(True);
			"Increase the index of the selected card by one, loop back to 0 when needed"
			Event Player.SelectedCardIndex = (Event Player.SelectedCardIndex + 1) % Count Of(Event Player.HandSymbols);
			Wait(0.060, Abort When False);
		End;
	}
}

rule("[Logic] Select card (previous)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player is holding primary fire"
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		"The player is not holding secondary fire"
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
		"The player is not a specator"
		Array Contains(Global.Players, Event Player) == True;
		"The event player is not holding ability one"
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		"Decrease the index of the selected car by one, loop back to the highest index when needed"
		Event Player.SelectedCardIndex = (Event Player.SelectedCardIndex + (Count Of(Event Player.HandSymbols) - 1)) % Count Of(
			Event Player.HandSymbols);
		Wait(0.250, Abort When False);
		"Fast scrolling"
		While(True);
			"Decrease the index of the selected car by one, loop back to the highest index when needed"
			Event Player.SelectedCardIndex = (Event Player.SelectedCardIndex + (Count Of(Event Player.HandSymbols) - 1)) % Count Of(
				Event Player.HandSymbols);
			Wait(0.060, Abort When False);
		End;
	}
}

rule("[Logic] Sort cards")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player pressed interact"
		Is Button Held(Event Player, Button(Interact)) == True;
		"The player has at least 2 cards"
		Count Of(Event Player.HandSymbols) >= 2;
		"Modifying a player's hand while they are rendering cards can create invalid HUD text elements"
		Global.IsCurrentlyPlayingAnimation == False;
		Event Player.IsCreatingHUDTexts == False;
		"The event player is not holding ability one"
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		"Sort the cards of the event player"
		Call Subroutine(SortHandCards);
		"Prevent the player from crashing the server"
		Wait(5, Ignore Condition);
	}
}

rule("[Effects] Show wild card error message")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player is trying to play a card"
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		"The event player must be the active player"
		Abort If(Event Player != First Of(Global.Players));
		"The card the player is trying to play is uncolored"
		Abort If(Event Player.HandColors[Event Player.SelectedCardIndex] != String("White"));
		"The card the player is trying to play is not a copycat card"
		Abort If(Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Copycat"));
		"Show an error message with instructions to change the color of the card"
		Big Message(Event Player, Custom String("Use {0} to select a color", Ability Icon String(Hero Of(Event Player), Button(Ability 2))
			== String("") ? String("Ability 2") : Ability Icon String(Hero Of(Event Player), Button(Ability 2))));
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 50);
	}
}

rule("[Subroutine] Sort cards")
{
	event
	{
		Subroutine;
		SortHandCards;
	}

	actions
	{
		"Reset the selected card index"
		Event Player.SelectedCardIndex = 0;
		"Find all wild symbols"
		Event Player.TempSymbols = Filtered Array(Event Player.HandSymbols, Array Contains(Append To Array(Custom String("Copycat"),
			Global.WILD_CARD_SYMBOLS), Current Array Element));
		"Sort the wild symbols, and add them to the temporary sorted symbol array"
		Event Player.TempSortedHandSymbols = Sorted Array(Event Player.TempSymbols, Index Of Array Value(Append To Array(Custom String(
			"Copycat"), Global.WILD_CARD_SYMBOLS), Current Array Element));
		"Reset the sorted hand colors temporary array"
		Event Player.TempSortedHandColors = Empty Array;
		"Loop until all newly added cards have been assigned a color"
		While(Count Of(Event Player.TempSortedHandSymbols) > Count Of(Event Player.TempSortedHandColors));
			"All cards in the symbol array are reset to white, even if they were colored before"
			Modify Player Variable(Event Player, TempSortedHandColors, Append To Array, String("White"));
		End;
		"Loop over every color"
		For Global Variable(TempColorIndex, 0, Count Of(Global.COLORS), 1);
			"Reset the temporary array"
			Event Player.TempSymbols = Empty Array;
			"Loop over all symbols the player has (can't use a filtered array here, since the index is needed to check the color but 'index of' always returns the first matching card)"
			For Global Variable(TempSymbolIndex, 0, Count Of(Event Player.HandSymbols), 1);
				"Check if the color of the current card being looped over is the current color being looped over, and the card is not a wild card"
				If(Event Player.HandColors[Global.TempSymbolIndex] == Global.COLORS[Global.TempColorIndex] && !Array Contains(Append To Array(
					Custom String("Copycat"), Global.WILD_CARD_SYMBOLS), Event Player.HandSymbols[Global.TempSymbolIndex]));
					"Append the current symbol being looped over to the temporary symbol array"
					Modify Player Variable(Event Player, TempSymbols, Append To Array, Event Player.HandSymbols[Global.TempSymbolIndex]);
					"Append the color for this card to the sorted hand colors array"
					Modify Player Variable(Event Player, TempSortedHandColors, Append To Array, Global.COLORS[Global.TempColorIndex]);
				End;
			End;
			"Sort the symbols for this color, and add them to the temporary sorted symbol array"
			Modify Player Variable(Event Player, TempSortedHandSymbols, Append To Array, Sorted Array(Event Player.TempSymbols,
				Index Of Array Value(Global.COLORED_CARD_SYMBOLS, Current Array Element)));
			"Loop until all newly added cards have been assigned a color"
			While(Count Of(Event Player.TempSortedHandSymbols) > Count Of(Event Player.TempSortedHandColors));
				"All cards in the symbol array are assigned the current color being looped over"
				Modify Player Variable(Event Player, TempSortedHandColors, Append To Array, Global.COLORS[Global.TempColorIndex]);
			End;
		End;
		"Set the player's cards to the sorted arrays"
		Event Player.HandSymbols = Event Player.TempSortedHandSymbols;
		Event Player.HandColors = Event Player.TempSortedHandColors;
		"Clear the hand HUD text elements of the event player"
		Global.PlayerToClearHand = Event Player;
		Call Subroutine(ClearHandHUDTexts);
		"Add the player's cards to the card render queue"
		Event Player.HandRenderQueueSymbols = Event Player.HandSymbols;
		Event Player.HandRenderQueueColors = Event Player.TempSortedHandColors;
	}
}

disabled rule("- CHEAT -")
{
	event
	{
		Ongoing - Global;
	}
}

disabled rule("[Setup][Cheat] setup cheat constants")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"When set to true certain cheats and permissions are enabled for the specified player admin."
		Global.SETTING_CHEAT_ENABLED = False;
		"Setting admin name"
		Global.CURRENT_ADMIN = Custom String("NotOnMyWatch");
		"Initialize the array used for displacement cheat"
		Global.PlayersSelectedForDisplacement = Empty Array;
	}
}

disabled rule("[Setup][Cheat] find and enable cheats for owner, set it to disabled by default for everyone else")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"If cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
	}

	actions
	{
		"If the current player is admin, enable cheat for them, if not set it to disabled by default"
		If(Custom String("{0}", Event Player) == Global.CURRENT_ADMIN);
			Event Player.CheatsEnabled = True;
		Else;
			Event Player.CheatsEnabled = False;
		End;
	}
}

disabled rule("[Logic][Cheat] toggle cheats on and off for other players as owner (v)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Check if the right combination of buttons is pressed"
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Button Held(Event Player, Button(Crouch)) == False;
		Is Button Held(Event Player, Button(Ability 2)) == False;
		"Check if the player is admin"
		Custom String("{0}", Event Player) == Global.CURRENT_ADMIN;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
	}

	actions
	{
		"if the closest player to reticle has cheats off"
		If(Player Closest To Reticle(Event Player, All Teams).CheatsEnabled == False);
			"enable cheats for selected player and show a message"
			Player Closest To Reticle(Event Player, All Teams).CheatsEnabled = True;
			Big Message(Event Player, Custom String("cheats enabled for {0}!", Player Closest To Reticle(Event Player, All Teams)));
		"if they already have cheats enabled"
		Else;
			"turn the cheats off for selected player and show a message"
			Player Closest To Reticle(Event Player, All Teams).CheatsEnabled = False;
			Big Message(Event Player, Custom String("cheats disabled for {0}!", Player Closest To Reticle(Event Player, All Teams)));
		End;
	}
}

disabled rule("[Logic][Cheat] select closest player to reticle to force displacement as owner (alt + v)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Check if the right combination of buttons is pressed"
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Ability 1)) == False;
		Is Button Held(Event Player, Button(Ability 2)) == False;
		"Check if the player is admin"
		Custom String("{0}", Event Player) == Global.CURRENT_ADMIN;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
	}

	actions
	{
		"select closest player to reticle "
		Modify Global Variable(PlayersSelectedForDisplacement, Append To Array, Player Closest To Reticle(Event Player, All Teams));
		"if it's the first select show a message and do nothing"
		If(Count Of(Global.PlayersSelectedForDisplacement) == 1);
			Big Message(Event Player, Custom String("First player, {0}, selected for displacement.", Player Closest To Reticle(Event Player,
				All Teams)));
		"if there are two players selected show a message and switch their position"
		Else If(Count Of(Global.PlayersSelectedForDisplacement) == 2);
			Big Message(Event Player, Custom String("Second player, {0}, selected for displacement. Displacement complete!",
				Player Closest To Reticle(Event Player, All Teams)));
			Call Subroutine(CompletePlayerPositionSwap);
		"fail safe, if more or none are selected reset the operation "
		Else;
			Big Message(Event Player, Custom String("An error occured please try again."));
			Global.PlayersSelectedForDisplacement = Empty Array;
		End;
	}
}

disabled rule("[Logic][Cheat] select self to force displacement as owner (alt + shift + v)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Check if the right combination of buttons is pressed"
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
		"Check if the player is admin"
		Custom String("{0}", Event Player) == Global.CURRENT_ADMIN;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
	}

	actions
	{
		"select self"
		Modify Global Variable(PlayersSelectedForDisplacement, Append To Array, Event Player);
		"if it's the first select show a message and do nothing"
		If(Count Of(Global.PlayersSelectedForDisplacement) == 1);
			Big Message(Event Player, Custom String("First player, {0}, selected for displacement.", Event Player));
		"if there are two players selected show a message and switch their position"
		Else If(Count Of(Global.PlayersSelectedForDisplacement) == 2);
			Big Message(Event Player, Custom String("Second player, {0}, selected for displacement. Displacement complete!", Event Player));
			Call Subroutine(CompletePlayerPositionSwap);
		"fail safe, if more or none are selected reset the operation "
		Else;
			Big Message(Event Player, Custom String("An error occured please try again."));
			Global.PlayersSelectedForDisplacement = Empty Array;
		End;
	}
}

disabled rule("[Logic][Cheat] force change selected card color (r)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Check if the right combination of buttons is pressed"
		Is Button Held(Event Player, Button(Reload)) == True;
		Is Button Held(Event Player, Button(Ability 1)) == False;
		Is Button Held(Event Player, Button(Crouch)) == False;
		"A player cannot change the color of cards when they are creating HUD texts"
		Event Player.IsCreatingHUDTexts == False;
		"Check if the player has host privileges"
		Event Player.CheatsEnabled == True;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
	}

	actions
	{
		"Cycle the color of the player's selected card"
		Event Player.HandColors[Event Player.SelectedCardIndex] = Global.COLORS[(Index Of Array Value(Global.COLORS,
			Event Player.HandColors[Event Player.SelectedCardIndex]) + 1) % Count Of(Global.COLORS)];
		"update the hud color"
		Call Subroutine(UpdateColorCheat);
	}
}

disabled rule("[Logic][Cheat] cycle selected card symbol (special symbols) (shift + r)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Check if the right combination of buttons is pressed"
		Is Button Held(Event Player, Button(Reload)) == True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Is Button Held(Event Player, Button(Crouch)) == False;
		"A player cannot change the color of cards when they are creating HUD texts"
		Event Player.IsCreatingHUDTexts == False;
		"Check if the player has host privileges"
		Event Player.CheatsEnabled == True;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
	}

	actions
	{
		"if it's a special card (non number/icon card)"
		If(Array Contains(Global.SPECIAL_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]));
			"cycle through the list of special cards and select the next one"
			Event Player.HandSymbols[Event Player.SelectedCardIndex] = Global.SPECIAL_CARD_SYMBOLS[(Index Of Array Value(
				Global.SPECIAL_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]) + 1) % Count Of(
				Global.SPECIAL_CARD_SYMBOLS)];
		Else;
			"if not select the first special card"
			Event Player.HandSymbols[Event Player.SelectedCardIndex] = First Of(Global.SPECIAL_CARD_SYMBOLS);
		End;
		"if the card is a white special card"
		If(Array Contains(Global.WHITE_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]));
			"set the color to white"
			Event Player.HandColors[Event Player.SelectedCardIndex] = Custom String("White");
		"if it's not a white special card and it already doesn't have a color"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("White") && !Array Contains(
				Global.WHITE_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]));
			"set the color to a random color "
			Event Player.HandColors[Event Player.SelectedCardIndex] = Global.COLORS[Random Integer(0, Count Of(Global.COLORS) - 1)];
		End;
		"render the hud text color"
		Call Subroutine(UpdateColorCheat);
	}
}

disabled rule("[Logic][Cheat] increase selected card number value (shift + m1)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Check if the right combination of buttons is pressed"
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
		Is Button Held(Event Player, Button(Reload)) == False;
		Is Button Held(Event Player, Button(Ability 2)) == False;
		"Check if the player has host privileges"
		Event Player.CheatsEnabled == True;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
		"A player cannot change the color of cards when they are creating HUD texts"
		Event Player.IsCreatingHUDTexts == False;
	}

	actions
	{
		"if the card is a number card"
		If(Array Contains(Global.NUMBER_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]));
			"increment the number"
			Event Player.HandSymbols[Event Player.SelectedCardIndex] = Global.NUMBER_CARD_SYMBOLS[(Index Of Array Value(
				Global.NUMBER_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]) + 1) % Global.SETTING_AMOUNT_OF_NUMBERS];
		Else;
			"if not just set the card to a 0 number card"
			Event Player.HandSymbols[Event Player.SelectedCardIndex] = First Of(Global.NUMBER_CARD_SYMBOLS);
		End;
		"if the card is white give it a random color"
		If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("White"));
			Event Player.HandColors[Event Player.SelectedCardIndex] = Global.COLORS[Random Integer(0, Count Of(Global.COLORS) - 1)];
		End;
		"render the hud text color"
		Call Subroutine(UpdateColorCheat);
	}
}

disabled rule("[Logic][Cheat] decrease selected card number value (shift + m2)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Check if the right combination of buttons is pressed"
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == False;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Is Button Held(Event Player, Button(Reload)) == False;
		Is Button Held(Event Player, Button(Ability 2)) == False;
		"Check if the player has host privileges"
		Event Player.CheatsEnabled == True;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
		"A player cannot change the color of cards when they are creating HUD texts"
		Event Player.IsCreatingHUDTexts == False;
	}

	actions
	{
		"if the card is a number card"
		If(Array Contains(Global.NUMBER_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]));
			"decrement the number"
			Event Player.TempNumber = (Index Of Array Value(Global.NUMBER_CARD_SYMBOLS,
				Event Player.HandSymbols[Event Player.SelectedCardIndex]) - 1) % Global.SETTING_AMOUNT_OF_NUMBERS;
			Event Player.HandSymbols[Event Player.SelectedCardIndex] = Global.NUMBER_CARD_SYMBOLS[Event Player.TempNumber >= 0 ? Event Player.TempNumber : Global.SETTING_AMOUNT_OF_NUMBERS + Event Player.TempNumber];
		Else;
			"if not just set the card to a 0 number card"
			Event Player.HandSymbols[Event Player.SelectedCardIndex] = First Of(Global.NUMBER_CARD_SYMBOLS);
		End;
		"if the card is white give it a random color"
		If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("White"));
			Event Player.HandColors[Event Player.SelectedCardIndex] = Global.COLORS[Random Integer(0, Count Of(Global.COLORS) - 1)];
		End;
		"render the hud text color"
		Call Subroutine(UpdateColorCheat);
	}
}

disabled rule("[Logic][Cheat] replace selected card with a random number card (shift + e)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Check if the right combination of buttons is pressed"
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == False;
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
		Is Button Held(Event Player, Button(Reload)) == False;
		Is Button Held(Event Player, Button(Ability 2)) == True;
		"Check if the player has host privileges"
		Event Player.CheatsEnabled == True;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
	}

	actions
	{
		"add the current card from hand to deck"
		Call Subroutine(TransferToDeckCheat);
		"remove the card from hand"
		Call Subroutine(DiscardCardCheat);
		"add a random number card to hand"
		Call Subroutine(AddRandomNumberCardCheat);
	}
}

disabled rule("[Logic][Cheat] force play jump in (shift + space)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player is jumping"
		Is Button Held(Event Player, Button(Jump)) == True;
		"The player is not crouching"
		Is Button Held(Event Player, Button(Crouch)) == False;
		"Is using shift"
		Is Button Held(Event Player, Button(Ability 1)) == True;
		"Has host favor"
		Event Player.CheatsEnabled == True;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
		"check if player can't normally play the card"
		First Of(Global.Players) != Event Player;
		(Event Player.HandColors[Event Player.SelectedCardIndex] == String("White")
			|| Global.DiscardPileSymbol != Event Player.HandSymbols[Event Player.SelectedCardIndex] || (!Array Contains(
			Global.WILD_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex])
			&& Event Player.HandColors[Event Player.SelectedCardIndex] != Global.DiscardPileColor)) == True;
	}

	actions
	{
		"Modifying a players hand while something important is happening can cause invalid HUD text elements"
		Abort If(Global.IsCurrentlyPlayingAnimation || Event Player.IsCreatingHUDTexts);
		"The player has not recently played a card"
		Abort If(Event Player.JumpInCooldown);
		"add current card from hand to deck"
		Call Subroutine(TransferToDeckCheat);
		"copy the card color and symbol from discard pile"
		Event Player.HandSymbols[Event Player.SelectedCardIndex] = Global.DiscardPileSymbol;
		Event Player.HandColors[Event Player.SelectedCardIndex] = Global.DiscardPileColor;
		"render the card color and symbol change"
		Call Subroutine(UpdateColorCheat);
		"Set the highlight beam to the position of the event player"
		Global.HighlightBeamEffectAngle = Horizontal Angle From Direction(Event Player.MapPosition - Global.MapPosition);
		Global.HighlightBeamEffectTargetAngle = Global.HighlightBeamEffectAngle;
		"Set hacked effect to the player whose turn was taken"
		Set Status(First Of(Global.Players), Event Player, Hacked, 5);
		"Update the player queue to put the jumping player in front"
		Global.Players = Append To Array(Remove From Array(Global.Players, Array Slice(Global.Players, 0, Index Of Array Value(
			Global.Players, Event Player))), Array Slice(Global.Players, 0, Index Of Array Value(Global.Players, Event Player)));
		"Show a message"
		Small Message(All Players(All Teams), Custom String("{0} jumped in!", Event Player));
		"Play some effects at the location of the player"
		Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Position Of(Event Player), 30);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 50);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), 0.500 * Up + Event Player.MapPosition, 5);
		"Transfer the card to the discard pile"
		Call Subroutine(TransferCardToDiscardPile);
	}
}

disabled rule("[Logic][Cheat] force play (shift + space)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player is jumping"
		Is Button Held(Event Player, Button(Jump)) == True;
		"The player is not crouching"
		Is Button Held(Event Player, Button(Crouch)) == False;
		"Is using shift"
		Is Button Held(Event Player, Button(Ability 1)) == True;
		"Has host favor"
		Event Player.CheatsEnabled == True;
		"if cheats are enabled"
		Global.SETTING_CHEAT_ENABLED == True;
		"make sure player can't normally play the card"
		First Of(Global.Players) == Event Player;
		((Event Player.HandSymbols[Event Player.SelectedCardIndex] != Custom String("Copycat")
			&& Event Player.HandColors[Event Player.SelectedCardIndex] == String("White")) || (
			Global.CurrentPenalty != 0 && Event Player.HandSymbols[Event Player.SelectedCardIndex] != Custom String("Copycat")
			&& !Array Contains(Global.PENALTY_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex])) || !(
			Event Player.HandSymbols[Event Player.SelectedCardIndex] == Global.DiscardPileSymbol || Array Contains(Append To Array(
			Custom String("Copycat"), Global.WILD_CARD_SYMBOLS), Event Player.HandSymbols[Event Player.SelectedCardIndex])
			|| Global.DiscardPileColor == String("White")
			|| Event Player.HandColors[Event Player.SelectedCardIndex] == Global.DiscardPileColor)) == True;
	}

	actions
	{
		"Modifying a players hand while something important is happening can cause invalid HUD text elements"
		Abort If(Global.IsCurrentlyPlayingAnimation || Event Player.IsCreatingHUDTexts);
		"add current selected card from hand to the deck"
		Call Subroutine(TransferToDeckCheat);
		"copy the card from discard pile"
		Event Player.HandSymbols[Event Player.SelectedCardIndex] = Global.DiscardPileSymbol;
		Event Player.HandColors[Event Player.SelectedCardIndex] = Global.DiscardPileColor;
		Call Subroutine(UpdateColorCheat);
		"Transfer the card to the discard pile"
		Call Subroutine(TransferCardToDiscardPile);
	}
}

disabled rule("[Subroutine][Cheat] add random number card")
{
	event
	{
		Subroutine;
		AddRandomNumberCardCheat;
	}

	actions
	{
		"pick a random color and number"
		Event Player.TempColor = Global.COLORS[Random Integer(0, Count Of(Global.COLORS) - 1)];
		Event Player.TempNumber = Random Integer(0, Global.SETTING_AMOUNT_OF_NUMBERS - 1);
		"Add the card to the player's hand"
		Modify Player Variable(Event Player, HandSymbols, Append To Array, Custom String("{0}", Event Player.TempNumber));
		Modify Player Variable(Event Player, HandColors, Append To Array, Custom String("{0}", Event Player.TempColor));
		"Render the card"
		Modify Player Variable(Event Player, HandRenderQueueSymbols, Append To Array, Custom String("{0}", Event Player.TempNumber));
		Modify Player Variable(Event Player, HandRenderQueueColors, Append To Array, Custom String("{0}", Event Player.TempColor));
	}
}

disabled rule("[Subroutine][Cheat] add selected card to deck")
{
	event
	{
		Subroutine;
		TransferToDeckCheat;
	}

	actions
	{
		"Put the selected card back in the deck"
		Modify Global Variable(DeckSymbols, Append To Array, Event Player.HandSymbols[Event Player.SelectedCardIndex]);
		"Check whether the selected card is a wild card"
		If(Array Contains(Global.WHITE_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]));
			"Add a wild card back to the deck"
			Modify Global Variable(DeckColors, Append To Array, String("White"));
		Else;
			"Add a regular card back to the deck"
			Modify Global Variable(DeckColors, Append To Array, Event Player.HandColors[Event Player.SelectedCardIndex]);
		End;
	}
}

disabled rule("[Subroutine][Cheat] remove selected card from hand")
{
	event
	{
		Subroutine;
		DiscardCardCheat;
	}

	actions
	{
		"Remove the card from the player's hand"
		Modify Player Variable(Event Player, HandSymbols, Remove From Array By Index, Event Player.SelectedCardIndex);
		Modify Player Variable(Event Player, HandColors, Remove From Array By Index, Event Player.SelectedCardIndex);
		Modify Player Variable(Event Player, HandHUDTextSortOrders, Remove From Array By Index, Event Player.SelectedCardIndex);
		"Destroy the HUD text associated with the player's card"
		Destroy HUD Text(Event Player.HandHUDTexts[Event Player.SelectedCardIndex]);
		Modify Player Variable(Event Player, HandHUDTexts, Remove From Array By Index, Event Player.SelectedCardIndex);
	}
}

disabled rule("[Subroutine][Cheat] update selected card color")
{
	event
	{
		Subroutine;
		UpdateColorCheat;
	}

	actions
	{
		"Destroy the currently selected HUD text"
		Destroy HUD Text(Event Player.HandHUDTexts[Event Player.SelectedCardIndex]);
		"The the selected card is red"
		If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Red"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Red), Color(Red), Color(Red), Visible To,
				Visible Never);
		"The next card in queue is orange"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Orange"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Orange), Color(Orange), Color(Orange), Visible To,
				Visible Never);
		"The next card in queue is yellow"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Yellow"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Yellow), Color(Yellow), Color(Yellow), Visible To,
				Visible Never);
		"The next card in queue is lime green"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Lime Green"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Lime Green), Color(Lime Green), Color(Lime Green),
				Visible To, Visible Never);
		"The next card in queue is green"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Green"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Green), Color(Green), Color(Green), Visible To,
				Visible Never);
		"The next card in queue is turquoise"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Turquoise"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Turquoise), Color(Turquoise), Color(Turquoise),
				Visible To, Visible Never);
		"The next card in queue is aqua"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Aqua"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Aqua), Color(Aqua), Color(Aqua), Visible To,
				Visible Never);
		"The next card in queue is sky blue"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == Custom String("Sky Blue"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Sky Blue), Color(Sky Blue), Color(Sky Blue),
				Visible To, Visible Never);
		"The next card in queue is blue"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Blue"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Blue), Color(Blue), Color(Blue), Visible To,
				Visible Never);
		"The next card in queue is purple"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("Purple"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(Purple), Color(Purple), Color(Purple), Visible To,
				Visible Never);
		"The next card in queue is purple"
		Else If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("White"));
			"Create a new HUD text with the correct color with the same sort order value"
			Create HUD Text(Event Player, Event Player.HandSymbols[Event Player.SelectedCardIndex], Null, Null, Left,
				Event Player.HandHUDTextSortOrders[Event Player.SelectedCardIndex], Color(White), Color(White), Color(White), Visible To,
				Visible Never);
		End;
		"Keep track of the HUD text ID to delete it when the card is played"
		Event Player.HandHUDTexts[Event Player.SelectedCardIndex] = Last Text ID;
	}
}

disabled rule("[Subroutine][Cheat] complete displacement operation")
{
	event
	{
		Subroutine;
		CompletePlayerPositionSwap;
	}

	actions
	{
		"switch the map position of selected players"
		Global.TempMapPosition = Global.PlayersSelectedForDisplacement[0].MapPosition;
		Global.PlayersSelectedForDisplacement[0].MapPosition = Global.PlayersSelectedForDisplacement[1].MapPosition;
		Global.PlayersSelectedForDisplacement[1].MapPosition = Global.TempMapPosition;
		"teleport them to their new map position values"
		Teleport(Global.PlayersSelectedForDisplacement[0], Global.PlayersSelectedForDisplacement[0].MapPosition);
		Teleport(Global.PlayersSelectedForDisplacement[1], Global.PlayersSelectedForDisplacement[1].MapPosition);
		"Reset the facing of the player towards the center"
		Set Facing(Global.PlayersSelectedForDisplacement[0], Global.MapPosition - Global.PlayersSelectedForDisplacement[0].MapPosition,
			To World);
		Set Facing(Global.PlayersSelectedForDisplacement[1], Global.MapPosition - Global.PlayersSelectedForDisplacement[1].MapPosition,
			To World);
		"swap the array element associated with selected players in the players array"
		Global.PlayersSelectedForDisplacementID[0] = Index Of Array Value(Global.Players, Global.PlayersSelectedForDisplacement[0]);
		Global.PlayersSelectedForDisplacementID[1] = Index Of Array Value(Global.Players, Global.PlayersSelectedForDisplacement[1]);
		Global.Players[Global.PlayersSelectedForDisplacementID[0]] = Global.PlayersSelectedForDisplacement[1];
		Global.Players[Global.PlayersSelectedForDisplacementID[1]] = Global.PlayersSelectedForDisplacement[0];
		"swap is complete, these values are no longer necessary"
		Global.PlayersSelectedForDisplacement = Empty Array;
		Global.PlayersSelectedForDisplacementID = Empty Array;
		"update player selection queue for all"
		Call Subroutine(SetPlayerSelectionQueueForAll);
	}
}

disabled rule("- CARD PLAYING LOGIC -")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[Logic] Play selected card")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"This rule is checked every time a player jumps, to prevent them from simply holding the jump button"
		Is Button Held(Event Player, Button(Jump)) == True;
		"Player is not crouching, prevents players from playing a card and drawing a card at the same time"
		Is Button Held(Event Player, Button(Crouch)) == False;
		disabled Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		"Modifying a players hand while something important is happening can cause invalid HUD text elements"
		Abort If(Global.IsCurrentlyPlayingAnimation || Event Player.IsCreatingHUDTexts);
		"The event player must be the active player"
		Abort If(First Of(Global.Players) != Event Player);
		"The selected card is properly colored"
		Abort If(Event Player.HandSymbols[Event Player.SelectedCardIndex] != Custom String("Copycat")
			&& Event Player.HandColors[Event Player.SelectedCardIndex] == String("White"));
		"There is currently no penalty or the player is trying to increase the penalty"
		Abort If(Global.CurrentPenalty != 0 && Event Player.HandSymbols[Event Player.SelectedCardIndex] != Custom String("Copycat")
			&& !Array Contains(Global.PENALTY_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex]));
		"The player's card has the same symbol as the discard pile card or the player has a wild card selected or the discard pile card is an uncolored wild card or the player's card has the same color as the discard pile card"
		Abort If(!(Event Player.HandSymbols[Event Player.SelectedCardIndex] == Global.DiscardPileSymbol || Array Contains(Append To Array(
			Custom String("Copycat"), Global.WILD_CARD_SYMBOLS), Event Player.HandSymbols[Event Player.SelectedCardIndex])
			|| Global.DiscardPileColor == String("White")
			|| Event Player.HandColors[Event Player.SelectedCardIndex] == Global.DiscardPileColor));
		"Transfer the card to the discard pile"
		Call Subroutine(TransferCardToDiscardPile);
	}
}

rule("[Logic] Play selected card (jump in)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"The player is jumping"
		Is Button Held(Event Player, Button(Jump)) == True;
		"The player is not crouching"
		Is Button Held(Event Player, Button(Crouch)) == False;
		disabled Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		"Modifying a players hand while something important is happening can cause invalid HUD text elements"
		Abort If(Global.IsCurrentlyPlayingAnimation || Event Player.IsCreatingHUDTexts);
		"Jump-ins are enabled"
		Abort If(!Global.SETTING_JUMP_INS);
		"The event player is currently not the active player"
		Abort If(First Of(Global.Players) == Event Player);
		"The player has not recently played a card"
		Abort If(Event Player.JumpInCooldown);
		"The selected card is properly colored"
		Abort If(Event Player.HandColors[Event Player.SelectedCardIndex] == String("White"));
		"The discard pile card has the same symbol as the player's card"
		Abort If(Global.DiscardPileSymbol != Event Player.HandSymbols[Event Player.SelectedCardIndex]);
		"The player's card is a wild card or the color of the player's card matches the color of the discard pile card"
		Abort If(!Array Contains(Global.WILD_CARD_SYMBOLS, Event Player.HandSymbols[Event Player.SelectedCardIndex])
			&& Event Player.HandColors[Event Player.SelectedCardIndex] != Global.DiscardPileColor);
		"Set the highlight beam to the position of the event player"
		Global.HighlightBeamEffectAngle = Horizontal Angle From Direction(Event Player.MapPosition - Global.MapPosition);
		Global.HighlightBeamEffectTargetAngle = Global.HighlightBeamEffectAngle;
		"Set hacked effect to the player whose turn was taken"
		Set Status(First Of(Global.Players), Event Player, Hacked, 5);
		"Update the player queue to put the jumping player in front"
		Global.Players = Append To Array(Remove From Array(Global.Players, Array Slice(Global.Players, 0, Index Of Array Value(
			Global.Players, Event Player))), Array Slice(Global.Players, 0, Index Of Array Value(Global.Players, Event Player)));
		"Show a message"
		Small Message(All Players(All Teams), Custom String("{0} jumped in!", Event Player));
		"Play some effects at the location of the player"
		Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Position Of(Event Player), 30);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 50);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), 0.500 * Up + Event Player.MapPosition, 5);
		"Transfer the card to the discard pile"
		Call Subroutine(TransferCardToDiscardPile);
	}
}

rule("[Subroutine] Transfer selected card to the discard pile")
{
	event
	{
		Subroutine;
		TransferCardToDiscardPile;
	}

	actions
	{
		"A copycat card was played"
		If(Event Player.HandSymbols[Event Player.SelectedCardIndex] == Custom String("Copycat"));
			"Show a message"
			Small Message(All Players(All Teams), Custom String("{0} copied {1}'s card!", Event Player, Global.LastPlayedCardPlayer));
			"Add the card back to the deck"
			Modify Global Variable(DeckSymbols, Append To Array, Custom String("Copycat"));
			Modify Global Variable(DeckColors, Append To Array, String("White"));
		"A non-copycat card has been played"
		Else;
			"Set the variable for copycat messages to this player"
			Global.LastPlayedCardPlayer = Event Player;
			"Put the discard pile card back in the deck"
			Modify Global Variable(DeckSymbols, Append To Array, Global.DiscardPileSymbol);
			"Check whether the discard pile card is a wild card"
			If(Array Contains(Global.WILD_CARD_SYMBOLS, Global.DiscardPileSymbol));
				"Add a wild card back to the deck"
				Modify Global Variable(DeckColors, Append To Array, String("White"));
			Else;
				"Add a regular card back to the deck"
				Modify Global Variable(DeckColors, Append To Array, Global.DiscardPileColor);
			End;
			"Transfer the card to the discard pile"
			Global.DiscardPileSymbol = Event Player.HandSymbols[Event Player.SelectedCardIndex];
			Global.DiscardPileColor = Event Player.HandColors[Event Player.SelectedCardIndex];
		End;
		"Remove the card from the player's hand"
		Modify Player Variable(Event Player, HandSymbols, Remove From Array By Index, Event Player.SelectedCardIndex);
		Modify Player Variable(Event Player, HandColors, Remove From Array By Index, Event Player.SelectedCardIndex);
		Modify Player Variable(Event Player, HandHUDTextSortOrders, Remove From Array By Index, Event Player.SelectedCardIndex);
		"Destroy the HUD text associated with the player's card"
		Destroy HUD Text(Event Player.HandHUDTexts[Event Player.SelectedCardIndex]);
		Modify Player Variable(Event Player, HandHUDTexts, Remove From Array By Index, Event Player.SelectedCardIndex);
		"Clamp the selected card index"
		Event Player.SelectedCardIndex = Min(Event Player.SelectedCardIndex, Count Of(Event Player.HandSymbols) - 1);
		"Prevent the player from jumping in too fast"
		Event Player.JumpInCooldown = 2;
		Chase Player Variable At Rate(Event Player, JumpInCooldown, 0, 1, Destination and Rate);
		"Play the an animation moving the played card to the discard pile"
		Global.DiscardPileSymbolMovementTimer = 1;
		Global.LastPlayedCardPosition = Position Of(Event Player);
		"Player should not play cards while the animation is happening"
		Global.IsCurrentlyPlayingAnimation += 1;
		"Wait for the animation to finish"
		Wait(1, Ignore Condition);
		Global.IsCurrentlyPlayingAnimation -= 1;
		"Play some effects"
		Play Effect(All Players(All Teams), Ring Explosion, Color(White), Global.MapPosition, 11);
		Play Effect(All Players(All Teams), Buff Explosion Sound, Color(White), Global.MapPosition, 30);
		Global.DiscardPileColorMovementTimer = 0 - (Global.DiscardPileColor != Global.DiscardPileLastColor);
		Global.DiscardPileLastColor = Global.DiscardPileColor;
		"Check whether the player has won"
		If(Count Of(Event Player.HandSymbols) == 0);
			"End the game"
			Declare Player Victory(Event Player);
		Else;
			"Pass the turn to the next player"
			Call Subroutine(ChangeActivePlayer);
		End;
	}
}

rule("[Subroutine] Change active player")
{
	event
	{
		Subroutine;
		ChangeActivePlayer;
	}

	actions
	{
		"A skip has been played or there are 2 players and a reverse has been played"
		If(Global.DiscardPileSymbol == Custom String("Skip") || (Count Of(Global.Players)
			== 2 && Global.DiscardPileSymbol == Custom String("Reverse")));
			Call Subroutine(ChangeActivePlayer_Skip);
		"A reverse has been played"
		Else If(Global.DiscardPileSymbol == Custom String("Reverse"));
			Call Subroutine(ChangeActivePlayer_Reverse);
		"A penalty card has been played"
		Else If(Array Contains(Global.PENALTY_CARD_SYMBOLS, Global.DiscardPileSymbol));
			Call Subroutine(ChangeActivePlayer_Penalty);
		"A swap has been played and there is a player to be swapped with"
		Else If(Global.DiscardPileSymbol == Custom String("Swap") && Count Of(Event Player.SelectedPlayerQueue) > 0);
			Call Subroutine(ChangeActivePlayer_Swap);
		"A swap all card has been played"
		Else If(Global.DiscardPileSymbol == Custom String("Swap-All"));
			Call Subroutine(ChangeActivePlayer_SwapAll);
		"A shuffle card has been played"
		Else If(Global.DiscardPileSymbol == Custom String("Shuffle"));
			Call Subroutine(ChangeActivePlayer_Shuffle);
		"A card has been played with no special behaviour"
		Else;
			Call Subroutine(ChangeActivePlayer_Default);
		End;
		"Reset the remaining turn time"
		Global.TurnTimeRemaining = Global.SETTING_TURN_TIME_LIMIT;
		"Reset the highlight pulse timer"
		Global.HighlightEffectPulseTimer = 0;
		"Move the highlight beam"
		Call Subroutine(UpdateHighlightBeamPosition);
	}
}

rule("[Subroutine] Change active player (default)")
{
	event
	{
		Subroutine;
		ChangeActivePlayer_Default;
	}

	actions
	{
		"The current active player is placed at the back of the queue"
		Modify Global Variable(Players, Append To Array, First Of(Global.Players));
		Modify Global Variable(Players, Remove From Array By Index, 0);
	}
}

rule("[Subroutine] Change active player (skip)")
{
	event
	{
		Subroutine;
		ChangeActivePlayer_Skip;
	}

	actions
	{
		"Show a message"
		Small Message(All Players(All Teams), Custom String("{0} skipped {1}!", Event Player, Global.Players[(1 + Index Of Array Value(
			Global.Players, Event Player)) % Count Of(Global.Players)]));
		"Advance to the player which should be skipped"
		Call Subroutine(ChangeActivePlayer_Default);
		"Freeze the skipped player"
		Set Status(First Of(Global.Players), Last Of(Global.Players), Frozen, 4);
		"Advance to the next player"
		Call Subroutine(ChangeActivePlayer_Default);
	}
}

rule("[Subroutine] Change active player (reverse)")
{
	event
	{
		Subroutine;
		ChangeActivePlayer_Reverse;
	}

	actions
	{
		"Reverse the queue"
		Global.Players = Sorted Array(Global.Players, 0 - Index Of Array Value(Global.Players, Current Array Element));
		Global.DirectionOfPlayTimer = -5 * Global.DirectionOfPlay;
		Global.DirectionOfPlay *= -1;
	}
}

rule("[Subroutine] Change active player (penalty)")
{
	event
	{
		Subroutine;
		ChangeActivePlayer_Penalty;
	}

	actions
	{
		"Check whether a +2 was played"
		If(Global.DiscardPileSymbol == Custom String("+2") || (Global.CurrentPenalty == 0 && Global.DiscardPileSymbol == Custom String(
			"×2")));
			Global.CurrentPenalty += 2;
		"Check whether a +4 was played"
		Else If(Global.DiscardPileSymbol == Custom String("+4"));
			Global.CurrentPenalty += 4;
		"Check whether a ×2 was played"
		Else If(Global.DiscardPileSymbol == Custom String("×2"));
			Global.CurrentPenalty *= 2;
		End;
		"Advance to the next player"
		Call Subroutine(ChangeActivePlayer_Default);
	}
}

rule("[Subroutine] Change active player (swap)")
{
	event
	{
		Subroutine;
		ChangeActivePlayer_Swap;
	}

	actions
	{
		"Preload the heroes"
		disabled Preload Hero(Event Player, Hero Of(First Of(Event Player.SelectedPlayerQueue)));
		disabled Preload Hero(First Of(Event Player.SelectedPlayerQueue), Hero Of(Event Player));
		"Play the animation"
		Call Subroutine(PlaySwapCardAnimation);
		"Clear the hand HUD text elements of the event player"
		Global.PlayerToClearHand = Event Player;
		Call Subroutine(ClearHandHUDTexts);
		"Clear the hand HUD text elements of the event player"
		Global.PlayerToClearHand = First Of(Event Player.SelectedPlayerQueue);
		Call Subroutine(ClearHandHUDTexts);
		"Swap the symbols of the players and set the render queues"
		Event Player.HandRenderQueueSymbols = First Of(Event Player.SelectedPlayerQueue).HandSymbols;
		First Of(Event Player.SelectedPlayerQueue).HandRenderQueueSymbols = Event Player.HandSymbols;
		Event Player.HandSymbols = Event Player.HandRenderQueueSymbols;
		First Of(Event Player.SelectedPlayerQueue).HandSymbols = First Of(Event Player.SelectedPlayerQueue).HandRenderQueueSymbols;
		"Swap the colors of the players and set the render queues"
		Event Player.HandRenderQueueColors = First Of(Event Player.SelectedPlayerQueue).HandColors;
		First Of(Event Player.SelectedPlayerQueue).HandRenderQueueColors = Event Player.HandColors;
		Event Player.HandColors = Event Player.HandRenderQueueColors;
		First Of(Event Player.SelectedPlayerQueue).HandColors = First Of(Event Player.SelectedPlayerQueue).HandRenderQueueColors;
		"Reset the selected card index"
		Event Player.SelectedCardIndex = 0;
		First Of(Event Player.SelectedPlayerQueue).SelectedCardIndex = 0;
		"Swap the heroes of the swapped players"
		disabled Global.TempHero = Hero Of(Event Player);
		disabled Start Forcing Player To Be Hero(Event Player, Hero Of(First Of(Event Player.SelectedPlayerQueue)));
		disabled Start Forcing Player To Be Hero(First Of(Event Player.SelectedPlayerQueue), Global.TempHero);
		"Advance to the next player"
		Call Subroutine(ChangeActivePlayer_Default);
	}
}

rule("[Subroutine] Change active player (swap all)")
{
	event
	{
		Subroutine;
		ChangeActivePlayer_SwapAll;
	}

	actions
	{
		"Loop over every player once before the animation"
		disabled For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
		"Preload every hero"
		disabled Preload Hero(Global.Players[(Global.TempPlayerIndex + 1) % Count Of(Global.Players)], Hero Of(
			Global.Players[Global.TempPlayerIndex]));
		disabled End;
		"Play the animation"
		Call Subroutine(PlaySpecialCardAnimation);
		"Save the hero of the last player"
		disabled Global.TempHero = Hero Of(Last Of(Global.Players));
		"Loop over every player once"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			"Set the hero of the next player"
			disabled Start Forcing Player To Be Hero(Global.Players[(Global.TempPlayerIndex + 1) % Count Of(Global.Players)], Hero Of(
				Global.Players[Global.TempPlayerIndex]));
			"Clear the hand HUD text elements of the current player"
			Global.PlayerToClearHand = Global.Players[Global.TempPlayerIndex];
			Call Subroutine(ClearHandHUDTexts);
			"Store the hand of the current player in the hand render queue of the next player"
			Global.Players[(Global.TempPlayerIndex + 1) % Count Of(Global.Players)
				].HandRenderQueueSymbols = Global.Players[Global.TempPlayerIndex].HandSymbols;
			Global.Players[(Global.TempPlayerIndex + 1) % Count Of(Global.Players)
				].HandRenderQueueColors = Global.Players[Global.TempPlayerIndex].HandColors;
			"Reset the selected card index of the current player"
			Global.Players[Global.TempPlayerIndex].SelectedCardIndex = 0;
			"Play an effect at the current player"
			Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Position Of(Global.Players[Global.TempPlayerIndex]), 40);
		End;
		"Set the hero of the first player"
		disabled Start Forcing Player To Be Hero(First Of(Global.Players), Global.TempHero);
		"Loop over every player a second time to set the hand variables"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			"Set the hand of the current player to the hand stored in it's render queue, leave the render queue such that the hand can be rendered"
			Global.Players[Global.TempPlayerIndex].HandSymbols = Global.Players[Global.TempPlayerIndex].HandRenderQueueSymbols;
			Global.Players[Global.TempPlayerIndex].HandColors = Global.Players[Global.TempPlayerIndex].HandRenderQueueColors;
		End;
		"Advance to the next player"
		Call Subroutine(ChangeActivePlayer_Default);
		"Show a message"
		Small Message(All Players(All Teams), Custom String("All hands swapped!"));
	}
}

rule("[Subroutine] Change active player (shuffle)")
{
	event
	{
		Subroutine;
		ChangeActivePlayer_Shuffle;
	}

	actions
	{
		Call Subroutine(PlaySpecialCardAnimation);
		"Store the deck"
		Global.TempSymbolIndex = Global.DeckSymbols;
		Global.TempColorIndex = Global.DeckColors;
		"Empty the deck"
		Global.DeckSymbols = Empty Array;
		Global.DeckColors = Empty Array;
		"Loop over every player once"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			"Set the requested cards for the current player"
			Global.Players[Global.TempPlayerIndex].AmountOfRequestedCards = Count Of(Global.Players[Global.TempPlayerIndex].HandSymbols);
			"Add the player's cards to the deck"
			Modify Global Variable(DeckSymbols, Append To Array, Global.Players[Global.TempPlayerIndex].HandSymbols);
			Modify Global Variable(DeckColors, Append To Array, Global.Players[Global.TempPlayerIndex].HandColors);
			"Clear the hand HUD text elements of the current player"
			Global.PlayerToClearHand = Global.Players[Global.TempPlayerIndex];
			Call Subroutine(ClearHandHUDTexts);
			"Clear the player's cards"
			Global.Players[Global.TempPlayerIndex].HandSymbols = Empty Array;
			Global.Players[Global.TempPlayerIndex].HandColors = Empty Array;
			"Reset the selected card index of the current player"
			Global.Players[Global.TempPlayerIndex].SelectedCardIndex = 0;
			"Play an effect at the current player"
			Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Position Of(Global.Players[Global.TempPlayerIndex]), 40);
		End;
		"Loop over every player a second time, the deck now contains all player hands"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			"Set the player to deal to and request the cards"
			Global.PlayerToDealTo = Global.Players[Global.TempPlayerIndex];
			Call Subroutine(DealRequestedCards);
		End;
		"Restore the deck"
		Global.DeckSymbols = Global.TempSymbolIndex;
		Global.DeckColors = Global.TempColorIndex;
		"Advance to the next player"
		Call Subroutine(ChangeActivePlayer_Default);
		"Show a message"
		Small Message(All Players(All Teams), Custom String("All hands shuffled!"));
	}
}

rule("[Subroutine][Effects] Play swap card animation")
{
	event
	{
		Subroutine;
		PlaySwapCardAnimation;
	}

	actions
	{
		"Set the volume of the sound effects to 0 so it can slowly be chased back to maximum volume"
		Global.SpecialCardSoundEffectVolume = 0;
		"Loop over both players"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.SwapCardEffectPlayers), 1);
			"Stop any motion"
			Apply Impulse(Global.SwapCardEffectPlayers[Global.TempPlayerIndex], Down, 0.001, To World, Cancel Contrary Motion);
			Apply Impulse(Global.SwapCardEffectPlayers[Global.TempPlayerIndex], Backward, 0.001, To World, Cancel Contrary Motion);
			Apply Impulse(Global.SwapCardEffectPlayers[Global.TempPlayerIndex], Forward, 0.001, To World, Cancel Contrary Motion);
			Apply Impulse(Global.SwapCardEffectPlayers[Global.TempPlayerIndex], Right, 0.001, To World, Cancel Contrary Motion);
			Apply Impulse(Global.SwapCardEffectPlayers[Global.TempPlayerIndex], Left, 0.001, To World, Cancel Contrary Motion);
		End;
		"Start an effect between the active and swapped player"
		Global.SwapCardEffectPlayers = Array(First Of(Global.Players), First Of(First Of(Global.Players).SelectedPlayerQueue));
		"Add status effect"
		Set Status(Global.SwapCardEffectPlayers, Null, Rooted, 5);
		"Start raising players upwards"
		Start Accelerating(Global.SwapCardEffectPlayers, Up, 1000, 4.100, To World, Direction Rate and Max Speed);
		"Players should not play cards while the animation is happening"
		Global.IsCurrentlyPlayingAnimation += 1;
		Wait(5, Ignore Condition);
		Global.IsCurrentlyPlayingAnimation -= 1;
		"Stop acceleration effect"
		Stop Accelerating(All Players(All Teams));
		"Stop the effect between the active and swapped player"
		Global.SwapCardEffectPlayers = Null;
		"Play an effect at the active player"
		Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Position Of(First Of(Global.Players)), 40);
		"Play an effect at the swapped player"
		Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Position Of(First Of(First Of(Global.Players)
			.SelectedPlayerQueue)), 20);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Global.MapPosition, 100);
		"Show a message"
		Small Message(All Players(All Teams), Custom String("{0} swapped with {1}!", Event Player, First Of(
			Event Player.SelectedPlayerQueue)));
	}
}

rule("[Subroutine][Effects] Play special card animation")
{
	event
	{
		Subroutine;
		PlaySpecialCardAnimation;
	}

	actions
	{
		"Set the volume of the sound effects to 0 so it can slowly be chased back to maximum volume"
		Global.SpecialCardSoundEffectVolume = 0;
		"Loop over all players"
		For Global Variable(TempPlayerIndex, 0, Count Of(Global.Players), 1);
			"Stop any motion"
			Apply Impulse(Global.Players[Global.TempPlayerIndex], Down, 0.001, To World, Cancel Contrary Motion);
			Apply Impulse(Global.Players[Global.TempPlayerIndex], Backward, 0.001, To World, Cancel Contrary Motion);
			Apply Impulse(Global.Players[Global.TempPlayerIndex], Forward, 0.001, To World, Cancel Contrary Motion);
			Apply Impulse(Global.Players[Global.TempPlayerIndex], Right, 0.001, To World, Cancel Contrary Motion);
			Apply Impulse(Global.Players[Global.TempPlayerIndex], Left, 0.001, To World, Cancel Contrary Motion);
		End;
		"Add status effects"
		Set Status(Global.Players, Null, Rooted, 5);
		"Start raising players upwards"
		Start Accelerating(Global.Players, Up, 1000, 4.100, To World, Direction Rate and Max Speed);
		"Show the effects for all players"
		Global.ShouldShowSpecialCardEffects = True;
		"Players should not play cards while the animation is happening"
		Global.IsCurrentlyPlayingAnimation += 1;
		Wait(5, Ignore Condition);
		Global.IsCurrentlyPlayingAnimation -= 1;
		"Stop showing the effects"
		Global.ShouldShowSpecialCardEffects = False;
		"Stop acceleration effect"
		Stop Accelerating(All Players(All Teams));
		"Play some effects"
		Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), Global.MapPosition, 20);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Purple), Global.MapPosition, 40);
		"Play a sound effect"
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Global.MapPosition, 50);
	}
}

rule("[Subroutine][Effects] Set highlight beam target angle")
{
	event
	{
		Subroutine;
		UpdateHighlightBeamPosition;
	}

	actions
	{
		Global.HighlightBeamEffectTargetAngle = Horizontal Angle From Direction(First Of(Global.Players).MapPosition - Global.MapPosition);
		While(Global.DirectionOfPlay * Global.HighlightBeamEffectAngle < Global.DirectionOfPlay * Global.HighlightBeamEffectTargetAngle);
			Global.HighlightBeamEffectTargetAngle += -360 * Global.DirectionOfPlay;
		End;
		While(
			Global.DirectionOfPlay * Global.HighlightBeamEffectAngle - 360 > Global.DirectionOfPlay * Global.HighlightBeamEffectTargetAngle);
			Global.HighlightBeamEffectTargetAngle += 360 * Global.DirectionOfPlay;
		End;
	}
}
