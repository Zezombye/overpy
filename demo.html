<!--
 * This file is part of OverPy (https://github.com/Zezombye/overpy).
 * Copyright (c) 2019 Zezombye.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
-->
<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <link rel="icon" type="image/png" href="VS Code Extension/img/overpy.ico" />
        <title>OverPy Demo</title>

        <style>
            textarea {
                resize: vertical;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
            }

            body,
            textarea {
                color: #cccccc;
                background-color: #222222;
                scrollbar-color: #cccccc #222222;
            }

            a {
                color: lightblue;
            }

            .cm-editor {
                width: 100%;
                text-align: left;
                border: 2px solid gray;
                color: #cccccc;
                height: 320px;
            }

            .cm-content {
                white-space: pre-wrap !important;
                word-break: break-word !important;
                max-width: calc(100% - 32px);
            }

            .cm-cursor {
                border-color: #cccccc !important;
            }

            .cm-selectionBackground,
            ::selection {
                background-color: rgb(51, 153, 255) !important;
            }
        </style>
    </head>
    <body>
        <center>
            <a href="https://github.com/Zezombye/overpy"><h1>OverPy v9 language demo by Zezombye</h1></a>
            <p>
                <button onclick="demoAddText();">Add example text</button> | Language:
                <select id="languageInput">
                    <option value="en-US">English [en-US]</option>
                    <option value="de-DE">Deutsch [de-DE]</option>
                    <option value="es-ES">Español (EU) [es-ES]</option>
                    <option value="es-MX">Español (AL) [es-MX]</option>
                    <option value="fr-FR">Français [fr-FR]</option>
                    <option value="it-IT">Italiano [it-IT]</option>
                    <option value="ja-JP">日本語 [ja-JP]</option>
                    <option value="ko-KR">한국어 [ko-KR]</option>
                    <option value="pl-PL">Polski [pl-PL]</option>
                    <option value="pt-BR">Português [pt-BR]</option>
                    <option value="ru-RU">Русский [ru-RU]</option>
                    <option value="th-TH">Thai [th-TH]</option>
                    <option value="zh-CN">简体中文 [zh-CN]</option>
                    <option value="zh-TW">繁體中文 [zh-TW]</option>
                </select>
            </p>

            <div id="workshop-text" style="float: left; width: 33%">
                <p>Workshop text</p>
                <button onclick="demoDecompile()">Decompile</button>
                <textarea id="workshop-textarea" onkeyup="getTextareaLineNumber(this, 'workshop');" onmouseup="this.onkeyup();" rows="20" style="width: 100%" wrap="off" placeholder="Note: the decompiler only supports code copied directly from Overwatch.&#10;&#10;If you wish to decompile code generated by a third-party tool (including OverPy),&#10;paste it into Overwatch and copy it."></textarea>
                <p style="float: left">line <span id="workshop-textarea-line-number"></span>, col <span id="workshop-textarea-col-number"></span></p>
            </div>

            <div id="overpy-text" style="float: left; width: 33%">
                <p>OverPy text</p>
                <button onclick="demoCompile()">Compile</button>
                <div id="cm-overpy-text"></div>
            </div>

            <div id="compiled-text" style="float: right; width: 34%">
                <p>Compiled text</p>
                <button style="visibility: hidden">hidden</button>
                <textarea id="compiled-textarea" onkeyup="getTextareaLineNumber(this, 'compiled');" onmouseup="this.onkeyup();" rows="20" style="width: 100%" wrap="off"></textarea>
                <p style="float: left">line <span id="compiled-textarea-line-number"></span>, col <span id="compiled-textarea-col-number"></span></p>
            </div>
        </center>

        <script src="out/overpy_standalone.js"></script>

        <script>
            const decompileTest = `
#OverPy starter pack

#!setupTags

settings {
    "main": {
        "description": "Some awesome game mode"
    },
    "gamemodes": {
        "skirmish": {
            "enabledMaps": [
                "workshopIsland"
            ]
        },
        "general": {
            "heroLimit": "off",
            "respawnTime%": 30
        }
    }
}

rule "Teleport player on pressing interact":
    @Event eachPlayer
    @Condition eventPlayer.isHoldingButton(Button.INTERACT)
    eventPlayer.teleport(eventPlayer.getEyePosition() + eventPlayer.getFacingDirection()*5)
    #Hold the player in place, to reset falling velocity
    eventPlayer.startForcingPosition(eventPlayer.getPosition(), false)
    wait()
    eventPlayer.stopForcingPosition()

rule "Display position":
    @Event eachPlayer
    print("Position of {}: {}".format(eventPlayer, eventPlayer.getPosition()))
`.trimStart()

        </script>

        <script src="codemirror.min.js"></script>
        <script src="codemirror-persist-document-extension.js"></script>

        <script>
            const { basicSetup } = CM["codemirror"];
            const { EditorView, keymap } = CM["@codemirror/view"];
            const { indentWithTab, defaultKeymap, history, historyKeymap } = CM["@codemirror/commands"];
            const { LRLanguage, LanguageSupport, StreamLanguage, HighlightStyle, syntaxHighlighting, indentUnit, foldNodeProp, foldInside, indentNodeProp } = CM["@codemirror/language"];
            const { styleTags, tags } = CM["@lezer/highlight"];
            const { LRParser } = CM["@lezer/lr"];
            const { persistDocument } = CM["@overpy/codemirror-persist-document"];

            function getIndentForLine(state, line) {
                const spaces = /^\s*/.exec(state.doc.lineAt(line).text)?.[0].length;
                const tabs = /^\t*/.exec(state.doc.lineAt(line).text)?.[0].length;
                return Math.floor(spaces / 4) + tabs;
            }

            function autoIndentOnEnter({ state, dispatch }) {
                const changes = state.changeByRange((range) => {
                    const { from, to } = range,
                        line = state.doc.lineAt(from);

                    const indent = getIndentForLine(state, from);
                    let insert = "\n";
                    for (let i = 0; i < indent; i++) {
                        insert += "    ";
                    }

                    const openBracket = /[\{\(\[]/gm.exec(state.doc.lineAt(from).text)?.[0].length;
                    const closeBracket = /[\}\)\]]/gm.exec(state.doc.lineAt(from).text)?.[0].length;
                    if (openBracket && !closeBracket) insert += "    ";

                    return { changes: { from, to, insert }, range: EditorSelection.cursor(from + insert.length) };
                });

                dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
                return true;
            }

            const overpyHighlight = HighlightStyle.define([
                { tag: tags.keyword, color: "#C586C0" },
                { tag: tags.operator, color: "#569cd6" },
                { tag: tags.variableName, color: "#9CDCFE" },
                { tag: tags.string, color: "#ce9178" },
                { tag: tags.escape, color: "#d7ba7d" },
                { tag: tags.annotation, color: "#d16969" },
                { tag: tags.attributeValue, color: "#6796e6" },
                { tag: tags.number, color: "#b5cea8" },
                { tag: tags.labelName, color: "#4EC9B0" },
                { tag: tags.comment, color: "#6A9955" },
                { tag: tags.macroName, color: "#569cd6" },
                { tag: tags.invalid, color: "#f44747" },
                { tag: tags.propertyName, color: "#4FC1FF" },
                { tag: tags.processingInstruction, color: "#DCDCAA" },
                { tag: tags.className, color: "#d7ba7d" },
                { tag: tags.modifier, color: "#9CDCFE" },
            ]);

            const overpyLanguage = {
                startState: function () {
                    return {
                        isInLineComment: false,
                        isInMultilineComment: false,
                        stringChar: null,
                        isInMacro: false,
                        isInAnnotation: false,
                        isInGoto: false,
                    };
                },
                token: function (stream, state) {
                    if (stream.eatSpace()) {
                        return null;
                    }
                    if (stream.eol()) {
                        return null;
                    }
                    //console.log("current: |"+stream.peek()+"|, string char: |"+state.stringChar+"|");
                    if (state.stringChar) {
                        if (stream.match(/\\([\\"'nrtzbf]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|&\w+;)/)) {
                            return "escape";
                        }
                        if (stream.peek() === state.stringChar) {
                            state.stringChar = null;
                        }
                        stream.next();
                        return "string";
                    }
                    if (state.isInAnnotation) {
                        state.isInAnnotation = false;
                        stream.skipToEnd();
                        return "attributeValue";
                    }
                    if (state.isInGoto) {
                        state.isInGoto = false;
                        stream.skipToEnd();
                        return "labelName";
                    }
                    if (state.isInLineComment) {
                        if (!stream.match(/.*\\ *$/)) {
                            state.isInLineComment = false;
                        }
                        stream.skipToEnd();
                        return "comment";
                    }
                    if (state.isInMultilineComment) {
                        if (stream.match("*/")) {
                            state.isInMultilineComment = false;
                        } else {
                            stream.next();
                        }
                        return "comment";
                    }
                    if (state.isInMacro) {
                        if (!stream.match(/.*\\ *$/)) {
                            state.isInMacro = false;
                        }
                        stream.skipToEnd();
                        return "macroName";
                    }
                    if (stream.match(/(goto)\b/)) {
                        state.isInGoto = true;
                        return "keyword";
                    }
                    if (stream.match(/\b[a-z]+(?=["'])/)) {
                        return "modifier";
                    }
                    if (stream.match(/(if|else|elif|do|while|for|return|continue|false|true|null|lambda|pass|del|break|switch|case|default|def|rule|settings|globalvar|playervar|subroutine|unsigned|signed|int|float|bool|enum|const|macro|self)\b/)) {
                        return "keyword";
                    }
                    if (stream.match(/(False|True|None|Null|class|finally|is|try|from|nonlocal|with|as|yield|assert|except|raise|disabled|import)\b/)) {
                        return "invalid";
                    }
                    if (stream.match("/*")) {
                        state.isInMultilineComment = true;
                        return "comment";
                    }
                    if (stream.match(/(and|or|not|in)\b|((\+|\-|\*\*|\/|\%|\*|<|>)=?)|(\=)|\.|((min|max|\!)\=)/)) {
                        return "operator";
                    }
                    if (stream.match(/(eventPlayer|attacker|victim|eventDamage|eventHealing|eventWasCriticalHit|eventWasEnvironment|eventWasHealthPack|eventAbility|eventDirection|healee|healer|hostPlayer|localPlayer|loc|RULE_CONDITION|ruleCondition|RULE_START|__\w+__|[A-Z]|[A-D][A-Z])\b/)) {
                        return "variable";
                    }
                    if (stream.match(/[A-Z_\d]+\b/)) {
                        return "propertyName";
                    }
                    if (stream.match(/\b\w+(?=\()/)) {
                        return "processingInstruction";
                    }
                    if (stream.match(/\b[A-Z][a-z_]\w*\b/)) {
                        return "className";
                    }
                    if (stream.match(/@(Event|Hero|Team|Slot|SuppressWarnings)+\b/)) {
                        state.isInAnnotation = true;
                        return "annotation";
                    }
                    if (stream.match(/@\w+\b/)) {
                        return "annotation";
                    }
                    if (stream.match(/\b[+-]?(\d*\.)?\d+\b/)) {
                        return "number";
                    }
                    if (stream.match(/[A-Za-z\d_]+(?=:)/)) {
                        return "labelName";
                    }
                    if (stream.match(/\w+/)) {
                        return null;
                    }
                    if (stream.match("#!")) {
                        state.isInMacro = true;
                        return "macroName";
                    }
                    if (stream.match("#")) {
                        state.isInLineComment = true;
                        return "comment";
                    }
                    var char = stream.next().toString();
                    //console.log(char);
                    if (char === "'" || char === '"') {
                        state.stringChar = char;
                        return "string";
                    }
                    return null;
                },
            };

            var overpyTextEditorView = new EditorView({
                extensions: [syntaxHighlighting(overpyHighlight), StreamLanguage.define(overpyLanguage), history(), indentUnit.of("    "), keymap.of([indentWithTab, ...defaultKeymap, ...historyKeymap, { key: "Enter", run: autoIndentOnEnter }]), basicSetup, persistDocument("opyTextEditorDoc")],
                parent: document.getElementById("cm-overpy-text"),
            });
        </script>

        <script>
            function getTextareaLineNumber(textarea, name) {
                document.getElementById(name + "-textarea-line-number").innerHTML = textarea.value.substr(0, textarea.selectionStart).split("\n").length;
                document.getElementById(name + "-textarea-col-number").innerHTML = textarea.selectionStart - textarea.value.substr(0, textarea.selectionStart).lastIndexOf("\n");
            }

            function demoDecompile() {
                var str = " ";
                var language = document.getElementById("languageInput").value;

                try {
                    str = decompileAllRules(document.getElementById("workshop-textarea").value, language);
                } catch (e) {
                    console.log(e);
                    str = "" + e + ". Please ensure the code is copied directly from Overwatch. If it is, contact CactusPuppy about this";
                }
                //document.getElementById("overpy-textarea").value = str;
                overpyTextEditorView.dispatch({
                    changes: { from: 0, to: overpyTextEditorView.state.doc.length, insert: str },
                });
            }

            async function demoCompile() {
                var str = "";
                var language = document.getElementById("languageInput").value;
                try {
                    compilationResult = await compile(overpyTextEditorView.state.doc.toString(), language);
                    console.log(compilationResult);
                    str += "//Elements: " + compilationResult.nbElements + "\n";
                    if (compilationResult.activatedExtensions.length > 0) {
                        str += "//Extension points: " + compilationResult.spentExtensionPoints + "/" + (compilationResult.availableExtensionPoints < 0 ? "unknown" : compilationResult.availableExtensionPoints) + "\n";
                    }
                    str += compilationResult.result;
                    if (compilationResult.encounteredWarnings.length > 0) {
                        var strWarn = "/* Warnings were encountered:\n\n";
                        for (var warning of compilationResult.encounteredWarnings) {
                            strWarn += " - " + warning.message + "\n\n";
                        }
                        strWarn += "*/\n";
                        str = strWarn + str;
                    }
                } catch (e) {
                    console.log(e);
                    str = e;
                }
                document.getElementById("compiled-textarea").value = str;
            }

            function demoAddText() {

                overpyTextEditorView.dispatch({
                    changes: { from: 0, to: overpyTextEditorView.state.doc.length, insert: decompileTest },
                });
                document.getElementById("workshop-textarea").value = "";
                document.getElementById("compiled-textarea").value = "";
            }

            //catch ctrl+s to execute compile
            document.addEventListener("keydown", function (event) {
                if (event.ctrlKey && event.key === "s") {
                    event.preventDefault();
                    demoCompile();
                }
            });
        </script>
    </body>
</html>
