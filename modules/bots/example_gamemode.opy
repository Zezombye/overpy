
/*
This is an example gamemode for the OverPy pathfinding, that features a rudimentary Reinhardt dummy bot AI.
*/

settings {
    "main": {
        "description": "https://github.com/Zezombye/OverPy\n\nExample gamemode for the bots module\n\nCode: QD5XA"
    },
    "lobby": {
        "ffaSlots": 1
    },
    "gamemodes": {
        "ffa": {
            "enabledMaps": [
                "necropolis",
                "lijiangGarden",
                "ecopointAntarctica",
                "blackForest",
                "nepalShrine",
            ]
        },
        "general": {
            "gamemodeStartTrigger": "immediately",
            "heroLimit": "off",
            "respawnTime%": 10,
            "enableRandomHeroes": true,
        }
    },
    "heroes": {
        "allTeams": {
            "general": {
                "abilityCooldown%": 0,
                #"health%": 500,
                #"damageReceived%": 10,
            }
        }
    }
}

#!define NB_NODES len(nodePositions)
#!define IS_AUTOGENERATED false

#!extension spawnMoreDummyBots

#!include "pathfinding/compressedPathmaps/ecopoint_antarctica.opy"
#!include "pathfinding/compressedPathmaps/necropolis_no_spawns.opy"
#!include "pathfinding/compressedPathmaps/lijiang_garden.opy"
#!include "pathfinding/compressedPathmaps/black_forest.opy"
#!include "pathfinding/compressedPathmaps/nepal_shrine.opy"
#!include "pathfinding/pathmaps/ecopoint_antarctica.opy"
#!include "pathfinding/pathmaps/necropolis_no_spawns.opy"
#!include "pathfinding/pathmaps/lijiang_garden.opy"
#!include "pathfinding/pathmaps/black_forest.opy"
#!include "pathfinding/pathmaps/nepal_shrine.opy"


/*
For this example gamemode there will be 3 states for the AI which is a Reinhardt.

In the "idle" state, the bot has no enemy to target, or is dead.
He is not doing anything.

In the "walking" state, the bot has found a suitable enemy and will walk towards the targeted enemy, following the node graph. 
At all times the bot is looking at the targeted player, and will fire firecharges at him if he happens to be in line of sight.

If the bot enters in range of the player, defined as being less than 7m from the player, less than 1.2m vertically from the player (assuming the bot is below the player, else he can simply jump down), and in line of sight, he enters the "fighting" state.
In this state, it is considered that the bot can directly reach the targeted enemy (no more pathfinding needed).
As such, the node graph is no longer used in this state, and the bot will simply walk directly towards the player, while waving his big ass hammer.
This state lasts until the bot is no longer in range of the player (defined the same as above) for 5 seconds, after which he will revert to the walking state.
*/
enum BotWalkBehavior:
    IDLING,
    WALKING,
    FIGHTING, 

globalvar i
globalvar j
globalvar uncompressedData = []
globalvar timer
globalvar currentNodeArray
globalvar currentCharIdx
globalvar runLengthEncodingIdx
globalvar message
globalvar nbBots = createWorkshopSetting(int[1:24], "", "Number of bots", 1, 0)

playervar targetNode = -1 #-1 means there is no target node, so one must be found.
playervar destNode
playervar targetPlayer = null
playervar walkBehavior = BotWalkBehavior.IDLING
#If the bot does not reach the target node in time, the target node is reinitialized, as the bot was probably booped or similar.
playervar timeRemainingToNode
playervar name #needed because apparently spectators can't see dummy bot names

enum Message:
    NO_PATHMAP,
    DECOMPRESSING,
    FINISHED_DECOMPRESSION,


globalvar alphabet
globalvar compressedData
globalvar nodePositions

#!define NODE_RADIUS 1
#!define BOT_SPEED 5.5

#Put each map in its own rule, else we hit the rule size limit.
def loadLijiangGarden():
    alphabet = ALPHABET_LIJIANG_GARDEN
    compressedData = DATA_LIJIANG_GARDEN
    nodePositions = POSITIONS_LIJIANG_GARDEN

def loadNecropolis():
    alphabet = ALPHABET_NECROPOLIS
    compressedData = DATA_NECROPOLIS
    nodePositions = POSITIONS_NECROPOLIS

def loadEcopointAntarctica():
    alphabet = ALPHABET_ECOPOINT_ANTARCTICA
    compressedData = DATA_ECOPOINT_ANTARCTICA
    nodePositions = POSITIONS_ECOPOINT_ANTARCTICA

def loadBlackForest():
    alphabet = ALPHABET_BLACK_FOREST
    compressedData = DATA_BLACK_FOREST
    nodePositions = POSITIONS_BLACK_FOREST

def loadNepalShrine():
    alphabet = ALPHABET_NEPAL_SHRINE
    compressedData = DATA_NEPAL_SHRINE
    nodePositions = POSITIONS_NEPAL_SHRINE

rule "Load built-in pathmaps":
    @Condition not IS_AUTOGENERATED
    #Load the pathmap based on the map
    if getCurrentMap() == Map.NECROPOLIS:
        loadNecropolis()
    elif getCurrentMap() == Map.LIJIANG_GARDEN or getCurrentMap() == Map.LIJIANG_GARDEN_LNY:
        loadLijiangGarden()
    elif getCurrentMap() == Map.ECOPOINT_ANTARCTICA or getCurrentMap() == Map.ECOPOINT_ANTARCTICA_WINTER:
        loadEcopointAntarctica()
    elif getCurrentMap() == Map.BLACK_FOREST or getCurrentMap() == Map.BLACK_FOREST_WINTER:
        loadBlackForest()
    elif getCurrentMap() == Map.NEPAL_SHRINE:
        loadNepalShrine()
    else:
        message = Message.NO_PATHMAP
        return

rule "Initialize gamemode and decompress pathmap":
    print("load: {} | avg: {} | max: {}".format(getServerLoad(), getAverageServerLoad(), getPeakServerLoad()))
    print("No pathmap for map {}".format(getCurrentMap()) if message == Message.NO_PATHMAP else "Node graph out of date. Rebuilding... {}s elapsed".format(timer) if message == Message.DECOMPRESSING else "Finished loading pathmap in {}s".format(timer))

    #Uncompress the pathmap
    message = Message.DECOMPRESSING
    disableInspector()
    chase(timer, 9999, rate=1, ChaseReeval.NONE)

    uncompressedData[NB_NODES-1] = 0
    currentNodeArray[NB_NODES-1] = 0

    currentCharIdx = 0
    for i in range(min(len(compressedData), 256)):
        for j in range(0, strLen(compressedData[i]), 2):

            #We iterate backwards to not recalculate the length at each iteration.
            for runLengthEncodingIdx in range(alphabet.strIndex(compressedData[i].charAt(j)), 0, -1):
                #Here we subtract 1 because we must take "-1" into account, so the alphabet starts at -1.
                currentNodeArray[currentCharIdx % NB_NODES] = alphabet.strIndex(compressedData[i].charAt(j+1))-1
                currentCharIdx++
                if currentCharIdx % NB_NODES == 0:
                    if currentCharIdx > NB_NODES * NB_NODES:
                        break
                    uncompressedData[floor((currentCharIdx-1)/NB_NODES)] = currentNodeArray
        
        wait()

    #Remove compressed data and calculation variables to make the server less laggy.
    alphabet = null
    compressedData = null
    currentNodeArray = null
    
    stopChasingVariable(timer)
    enableInspector()
    message = Message.FINISHED_DECOMPRESSION

    #Now that we have finished decompressing, spawn the bots.
    for i in range(24):
        createDummy(Hero.REINHARDT, (Team.2 if i % 2 == 0 else Team.1) if getCurrentGamemode() != Gamemode.FFA else Team.ALL, 24-i if getCurrentGamemode() == Gamemode.FFA else floor(12-(i/2)), vect(0, -1000, 0), null)

rule "Initialize dummy":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    hudText(getAllPlayers(), 
        "{}".format(eventPlayer.name),
        "Targeting player: {}, mode: {}".format(eventPlayer.targetPlayer, "idling" if eventPlayer.walkBehavior == BotWalkBehavior.IDLING else "walking" if eventPlayer.walkBehavior == BotWalkBehavior.WALKING else "fighting"), 
        "Target node: {} ({}s left), dest node: {}".format(eventPlayer.targetNode, eventPlayer.timeRemainingToNode, eventPlayer.destNode),
        HudPosition.LEFT, eventPlayer.getSlot(), Color.WHITE, Color.WHITE, Color.WHITE, HudReeval.VISIBILITY_AND_STRING, SpecVisibility.ALWAYS
    )
    createEffect(getAllPlayers(), Effect.SPHERE, Color.GREEN, nodePositions[eventPlayer.destNode], NODE_RADIUS, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
    createEffect(getAllPlayers(), Effect.SPHERE, Color.BLUE, nodePositions[eventPlayer.targetNode], NODE_RADIUS, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
    createIcon(getAllPlayers(), eventPlayer, Icon.SKULL, IconReeval.VISIBILITY_AND_POSITION, Color.RED, true)
    chase(eventPlayer.timeRemainingToNode, 0, rate=1, ChaseReeval.NONE)
    eventPlayer.name = "Reinhardt {}".format(eventPlayer.getSlot())
    eventPlayer.startForcingName(eventPlayer.name)

rule "Bot is idling - stop throttle and pressing buttons":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.IDLING
    eventPlayer.stopForcingButton(Button.PRIMARY_FIRE)
    eventPlayer.stopThrottleInDirection()
    eventPlayer.stopFacing()
    eventPlayer.targetNode = -1
    eventPlayer.timeRemainingToNode = 0

rule "Find a suitable enemy":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.IDLING
    @Condition eventPlayer.hasSpawned()
    @Condition eventPlayer.isAlive()
    do:
        #Take the closest enemy player that is alive and spawned.
        eventPlayer.targetPlayer = sorted([p for p in getPlayers(getOppositeTeam(eventPlayer.getTeam())) if p != eventPlayer and p.isAlive() and p.hasSpawned()], lambda x: distance(eventPlayer, x))[0]
        wait(0.5)
    while RULE_CONDITION

rule "Periodically update destination node":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.WALKING
    do:
        #The destination node is the closest node that is in line of sight of the target player.
        eventPlayer.destNode = nodePositions.index(sorted([pos for pos in nodePositions if isInLoS(pos+vect(0,NODE_RADIUS,0), eventPlayer.targetPlayer.getEyePosition(), BarrierLos.PASS_THROUGH_BARRIERS)], lambda pos: distance(eventPlayer.targetPlayer.getPosition(), pos))[0])
        if eventPlayer.destNode == -1:
            eventPlayer.walkBehavior = BotWalkBehavior.IDLING
            return
        wait(1)
    while RULE_CONDITION


rule "An enemy was found - switch to walking mode":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.IDLING
    @Condition eventPlayer.targetPlayer != null
    eventPlayer.walkBehavior = BotWalkBehavior.WALKING
    eventPlayer.startFacing(directionTowards(eventPlayer.getEyePosition(), eventPlayer.targetPlayer.getPosition()+vect(0,1.5,0)), 9999, Relativity.TO_WORLD, FacingReeval.DIRECTION_AND_TURN_RATE)
    eventPlayer.startThrottleInDirection(directionTowards(eventPlayer.getPosition(), nodePositions[eventPlayer.targetNode]), 1, Relativity.TO_WORLD, Throttle.REPLACE_EXISTING, ThrottleReeval.DIRECTION_AND_MAGNITUDE)

rule "Initialize target node":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.WALKING
    @Condition eventPlayer.timeRemainingToNode == 0
    #Initialize the target node by getting the closest node to the bot which is in line of sight and not higher than 1.2m.
    #The bot will always walk directly towards the target node.
    eventPlayer.targetNode = nodePositions.index(sorted([pos for pos in nodePositions if pos.y - eventPlayer.getPosition().y < 1.2 and isInLoS(pos+vect(0,NODE_RADIUS,0), eventPlayer.getEyePosition(), BarrierLos.PASS_THROUGH_BARRIERS)], lambda pos: distance(eventPlayer.getPosition(), pos))[0])
    if eventPlayer.targetNode == -1:
        eventPlayer.walkBehavior = BotWalkBehavior.IDLING
        eventPlayer.stopThrottleInDirection()
        return
    #Put wiggle room by setting it to 2x the distance, in case the bot is slowed down by a boop, slight wall, or similar.
    eventPlayer.timeRemainingToNode = distance(nodePositions[eventPlayer.targetNode], eventPlayer.getPosition())*2/BOT_SPEED + 0.5

rule "Enemy is in range - set mode to fighting":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.WALKING
    @Condition abs(eventPlayer.getPosition().y - eventPlayer.targetPlayer.getPosition().y) < 1.2
    @Condition distance(eventPlayer, eventPlayer.targetPlayer) < 7
    @Condition isInLoS(eventPlayer.getEyePosition(), eventPlayer.targetPlayer.getEyePosition(), BarrierLos.PASS_THROUGH_BARRIERS)
    do:
        eventPlayer.walkBehavior = BotWalkBehavior.FIGHTING
        wait()
    while RULE_CONDITION

rule "Bot is fighting - set throttle towards enemy and start swinging":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.FIGHTING
    eventPlayer.startThrottleInDirection(directionTowards(eventPlayer.getPosition(), eventPlayer.targetPlayer.getPosition()), 1, Relativity.TO_WORLD, Throttle.REPLACE_EXISTING, ThrottleReeval.DIRECTION_AND_MAGNITUDE)
    eventPlayer.startForcingButton(Button.PRIMARY_FIRE)

rule "Enemy is no longer in range - set mode back to idling":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.FIGHTING
    @Condition abs(eventPlayer.getPosition().y - eventPlayer.targetPlayer.getPosition().y) >= 1.2 or distance(eventPlayer, eventPlayer.targetPlayer) >= 7 or not isInLoS(eventPlayer.getEyePosition(), eventPlayer.targetPlayer.getEyePosition(), BarrierLos.PASS_THROUGH_BARRIERS)
    do:
        wait(5, Wait.ABORT_WHEN_FALSE)
        eventPlayer.walkBehavior = BotWalkBehavior.IDLING
    while RULE_CONDITION

rule "Fire firecharges on enemy when in walking mode":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.WALKING
    @Condition isInLoS(eventPlayer.getEyePosition(), eventPlayer.targetPlayer.getEyePosition(), BarrierLos.PASS_THROUGH_BARRIERS)
    do:
        eventPlayer.forceButtonPress(Button.ABILITY_2)
        wait(random.uniform(0.5, 5), Wait.ABORT_WHEN_FALSE)
    while RULE_CONDITION

rule "Enemy is dead - set mode back to walking and enemy to null":
    @Event eachPlayer
    @Condition eventPlayer.targetPlayer.isDead() or not eventPlayer.targetPlayer.hasSpawned() or eventPlayer.isDead() or not eventPlayer.hasSpawned()
    eventPlayer.targetPlayer = null
    eventPlayer.walkBehavior = BotWalkBehavior.IDLING


rule "Jump over cliffs":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.WALKING or eventPlayer.walkBehavior == BotWalkBehavior.FIGHTING
    @Condition updateEveryTick(isInLoS(eventPlayer.getPosition()+normalize(eventPlayer.getThrottle())*0.2+vect(0,0.5,0), eventPlayer.getPosition()+normalize(eventPlayer.getThrottle())*0.2-vect(0,0.5,0), BarrierLos.PASS_THROUGH_BARRIERS))
    do:
        eventPlayer.forceButtonPress(Button.JUMP)
        wait()
    while RULE_CONDITION


rule "Jump over obstacles":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.WALKING or eventPlayer.walkBehavior == BotWalkBehavior.FIGHTING
    @Condition eventPlayer.getHorizontalSpeed() < 3
    do:
        eventPlayer.forceButtonPress(Button.JUMP)
        wait()
    while RULE_CONDITION
    

rule "Target node was reached":
    @Event eachPlayer
    @Condition eventPlayer.isDummy()
    @Condition eventPlayer.walkBehavior == BotWalkBehavior.WALKING
    @Condition eventPlayer.targetNode >= 0
    @Condition eventPlayer.getPosition().y > nodePositions[eventPlayer.targetNode].y - NODE_RADIUS
    @Condition updateEveryTick(distance(eventPlayer.getPosition()*vect(1,0,1), nodePositions[eventPlayer.targetNode]*vect(1,0,1))) < NODE_RADIUS
    @Condition updateEveryTick(isInLoS(eventPlayer.getEyePosition(), nodePositions[eventPlayer.targetNode]+vect(0,1,0), BarrierLos.PASS_THROUGH_BARRIERS))
    do:
        #This is all the magic of the bakemap.
        eventPlayer.targetNode = uncompressedData[eventPlayer.targetNode][eventPlayer.destNode]
        if eventPlayer.targetNode == -1:
            eventPlayer.walkBehavior = BotWalkBehavior.IDLING
            eventPlayer.stopThrottleInDirection()
            return
        if eventPlayer.targetNode == eventPlayer.destNode:
            eventPlayer.walkBehavior = BotWalkBehavior.FIGHTING
        #Put wiggle room by setting it to 2x the distance, in case the bot is slowed down by a boop, slight wall, or similar.
        eventPlayer.timeRemainingToNode = distance(nodePositions[eventPlayer.targetNode], eventPlayer.getPosition())*2/BOT_SPEED + 0.5
        wait()
    while RULE_CONDITION

